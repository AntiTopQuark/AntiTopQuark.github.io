---
layout: post
cid: 65
title: 我教我自己:分布式系统常用技术及案例分析(第2版)
slug: 65
date: 2021/04/13 20:28:37
updated: 2021/04/13 20:28:37
status: publish
author: AntiTopQuark
categories: 
  - 读书笔记
tags: 
  - 类型
  - 节点
  - 逻辑
  - 函数
  - 接口
  - 变量
  - 容器
  - 程序
  - 方法
  - commit
  - 语言
  - 内存
  - 数据库
  - 系统
  - 一致性
  - 扩展
  - 存储
  - 事务
  - 用户
  - 状态
  - 错误
  - 进程
  - 对象
  - 文件
  - 分区
  - 任务
  - 数据
  - 参与者
  - 操作
  - 故障
  - 笔记
  - 记录
  - 框架
  - 机器
  - remote
  - 协议
  - 客户端
  - 模型
  - 启动
  - 过程
  - 原理
  - 架构
  - 分布式
  - 服务器
  - 选举
  - 概述
  - 日志
  - 组织
  - 锁
  - 共享
  - redo
  - 区别
  - 准备
  - 环境
  - 内核
  - 优先
  - 软件
  - 开发
  - 程序员
  - 处理
  - 知识
  - 上下文
  - 1.1.1
  - 计算
  - 特征
  - 步骤
  - 股票
  - 知乎
  - 回答
  - 问题
  - 编程
  - 识别
  - 集合
  - 分隔
  - 算法
  - 表示
  - 动作
  - 虚拟
customSummary: 
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---


<!-- index-menu -->

# 第1章 分布式系统基础知识
## 1.1 概述
### 1.1.1 什么是分布式系统?
定义:分布式系统是若干独立计算机的集合,这些计算机对于用户来说就像单个系统。
包含两个要点:
- 硬件独立:是指机器本身是独立的。一个大型的分布式系统,由若干计算机组成系统的基础设施。
- 软件统一:是指对于用户来说,用户就像跟单个系统打交道。软件统一的另外一个方面是指,分布式系统的扩展和升级都比较容易。分布式系统中的某些节点发生故障,不会影响整体系统的可用性。用户和应用程序交互时,不会察觉哪些部分正在替换或维修,也不会感知新加入的部分

### 1.1.2 集中式系统与分布式系统
集中式系统:主要部署在高性能小型机以上档次的服务器中,所有功能都集成到主服务器上,对服务器性能要求高.
分布式系统:分布式系统通过中间件对现有计算机的硬件能力和相应的软件功能进行重新配置和整合。它是一种多处理器的计算机系统，各处理器通过网络构成统一的系统。系统采用分布式计算结构，即把原来系统内中央处理器处理的任务分散交给相应的处理器，实现不同功能的多个处理器，这些处理器的相互协调，共享系统的外设与软件。

![分布式系统示意图](http://www.sukidesu.top/usr/uploads/2020/10/2287372550.png)

### 1.1.3 如何设计分布式系统
设计分布式系统的本质就是“合理地将一个系统拆分成多个子系统并部署到不同的机器上”
概括起来，在设计分布式系统时，应考虑以下问题：
- 如何将系统拆分为子系统？
- 如何规划子系统间的通信？
- 如何考虑通信过程中的安全？
- 如何让子系统可以扩展？
- 如何保证子系统的可靠性？
- 如何实现数据的一致性？

### 1.1.4 分布式系统所面临的挑战

- 异构性：由于分布式系统基于不同的网络、操作系统、计算机硬件和编程语言构造，必须有一种通用的网络通信协议来屏蔽异构系统之间的差异。一般由中间件来处理这些差异。
- 缺乏全球时钟：在程序需要协作时，通过交换消息来协调它们的动作。紧密的协调经常依赖于对程序动作发生时间的共识。但是，实际网络上计算机同步时钟的准确性受到了极大的限制，即没有一个正确时间的全局概念。这是通过网络发送消息作为唯一的通信方式这一事实带来的直接结果。
- 一致性：数据被分散或复制到不同的机器上，如何保证各台主机之间的数据的一致性是一个难点。
- 故障的独立性：任何计算机都有可能发生故障，且故障不尽相同。故障出现的时间也是相互独立的。一般分布式系统允许出现部分故障而不影响整个系统的正常使用。
- 并发：使用分布式系统的目的是更好地共享资源，所以系统中的每个资源都必须被设计成在并发环境中是安全的。
- 透明性：分布式系统中任何组件的故障，或者主机的升级、迁移，对于用户来说都是不可见的。
- 开放性：分布式系统由不同的程序员来编写不同的组件，组件最终要集成为一个系统，所以组件所发布的接口必须遵守一定的规范且能够被互相理解。
- 安全性：加密用于给共享资源提供适当的保护，在网络上传递的所有敏感信息都需要进行加密。拒绝服务攻击仍然是一个有待解决的问题。
- 可扩展性：系统要设计成随着业务量的增加而相应地扩展，以提供对应的服务。

## 1.2 线程
太基础了,简单阅读后跳过,暂时不做笔记

## 1.3 通信
### 1.3.1 网络I/O模型的演进
#### 同步和异步
同步和异步描述的是用户线程与内核的交互方式：
● 同步是指用户线程发起I/O请求后需要等待，或者轮询内核I/O操作完成后才能继续执行；
● 异步是指用户线程发起I/O请求后仍继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数。

#### 阻塞和非阻塞
阻塞和非阻塞描述的是用户线程调用内核I/O操作的方式：
● 阻塞是指I/O操作需要彻底完成后才返回用户空间；
● 非阻塞是指I/O操作被调用后立即返回给用户一个状态值，无须等到I/O操作彻底完成。一个I/O

操作其实分成了两个步骤：发起I/O请求和实际的I/O操作。阻塞I/O和非阻塞I/O的区别在于第一步，也就是发起I/O请求是否会被阻塞。如果阻塞直到完成，就是传统的阻塞I/O，如果不阻塞，就是非阻塞I/O。同步I/O和异步I/O的区别在于第二个步骤是否阻塞，如果实际的I/O读写阻塞请求进程，就是同步I/O。

## 1.4 一致性
### 1.4.1 以数据为中心的一致性模型
一致性模型实质上是进程和数据存储之间的一个约定。在正常情况下，在一个数据项上执行读操作时，它期待该操作返回的是该数据在其最后一次写操作之后的结果。在没有全局时钟的情况下，很难精确地定义哪次写操作是最后一次写操作，于是就产生了一系列用其他方式定义的一致性模型。
#### 1．严格一致性（Strict Consistency）
任意读操作都要读到最新的写的结果。严格一致性是限制性最强的模型，依赖于绝对的全局时钟，但是在分布式系统中实现这种模型的代价太大，所以在实际系统中的运用有限，基本上不可能做到。
#### 2.持续一致性（Continuous Consistency）
例子:https://blog.csdn.net/weixin_34291004/article/details/91412676
有多种不同的方法来为应用程序指定它们能容忍哪些不一致性，其中有一种通用的方法，它定义了区分不一致性的三个互相独立的坐标轴：副本之间的数值偏差、副本之间的新旧程度偏差，以及更新操作顺序的偏差。这些偏差形成了持续一致性的范围。
数值偏差可以这样理解：已应用于其他的副本，但还没有应用于给定副本的更新数目。比如，Web缓存可能还没有得到Web服务器执行的一批操作。数值偏差限制了一个副本有多少未看到的其他副本写操作的权重（权重主要用于衡量不同写操作的重要性，当假设所有写操作权重相等时，权重即写操作的数量；当写操作的对象是数值时，可以用数值的差值作为权重），用于衡量当前副本值跟全局最终值之间的偏差。可以简单理解为未全局更新的写操作数量。例如在股票市场的价格记录的复制场景中，应用可以指定两个副本间的价格偏差不能超过 0.02 美元，这就是这个系统能够容忍的最大数值偏差。
新旧程度偏差与副本最近一次的更新有关。对于某些应用，只要副本提供的数据不是很旧，都是可以容忍的，比如，天气预报通常会滞后一段时间。
更新操作顺序的偏差是指，只要可以界定副本之间的差异，就允许不同的副本采用不同的更新顺序。顺序偏差限制了一个副本中暂存写操作的数量，用于衡量暂存的写操作在本地副本的顺序与最终提交的写操作全局最终顺序之间的差异。顺序偏差相对来说比较难理解，首先当允许副本间有差异的时候，那么必定有一个时刻副本会暂存一些写操作，这些写操作在全局提交之后才会成为永久更新，但是这些写操作不一定都能提交成功，它可能会回滚，这意味着副本暂存写操作的顺序跟最终提交的顺序不一定一致。然而暂存的写操作有哪些会回滚导致顺序不一致无法预测，因此为了方便起见，直接取暂存写操作的数量作为顺序偏差，因为这是顺序偏差的上限。这就是顺序偏差的计算规则的由来。举个例子，如果要计算两阶段分布式事务的顺序偏差，那么它的顺序偏差就是准备阶段写操作的数量。
#### 3.顺序一致性（Sequential Consistency）
https://blog.csdn.net/qq_29842929/article/details/80793341
任何执行结果都是相同的，就好像所有进程对数据存储的读或写操作是按某种序列顺序执行的一样，并且每个进程的操作按照程序所制定的顺序出现在这个序列中。
也就是说，任何读或写操作的交叉都是可接受的，但是所有进程都看到相同的操作交叉。
#### 4．因果一致性（Casual Consistency）
所有进程必须以相同的顺序看到具有潜在因果关系的写操作。不同机器上的进程可以以不同的顺序看到并发的写操作。假设P1和P2是有因果关系的两个进程，如果P2的写操作信赖于P1的写操作，那么P1和P2对x的修改顺序，在P3和P4看来一定是一样的。但如果P1和P2没有关系，那么P1和P2对x的修改顺序，在P3和P4看来可以是不一样的。相比顺序一致性，因果一致性去掉了那些没有联系的操作需达成一致顺序观点的要求，只保留了那些必要的顺序（有因果关系）。
反例:如果用户A提交一个问题，用户B提交了回答。问题写入了节点A，回答写入了节点B。因为同步延迟，发起查询的用户可能会先看到回答，再看到问题。
#### 5.入口一致性（Entry Consistency）
入口一致性其实也就是对每个共享的数据定义一个同步变量（锁）。当然，没有进行同步就进行读操作，是不能保证结果正确的。

### 1.4.2 以客户为中心的一致性
以客户为中心的一致性是指从用户的视角来看数据是一致的。客户只关心数据最终是否一致。只要保证同一个用户访问的数据是一致的就可以了。如果用户只是访问一个副本，则很好实现，否则就需要一定的策略了。当没有更多的更新时，要保证当前的更新最终会传播到所有副本上。著名的例子有DNS系统、万维网。
最终一致性需要注意一个典型的问题，即当客户访问不同的副本时，问题就出现了。更具体的例子比如，作者在博客上更改了一篇博文的内容，在A地的用户先访问到最新的内容，而B地由于离博客服务器远，读者看到的还是原先的内容。对于最终一致性的数据存储而言，这个示例很有代表性。问题是由用户有时可能对不同的副本进行操作引起的。以客户为中心的一致性分为如下几大类。
#### 1．单调读一致性（Monotonic-read Consistency）
当进程从一个地方读出数据x，那么以后再读到的x应该是和当前x相同或比当前更新的版本。也就是说，如果进程迁移到了别的位置，那么对x的更新应该比进程先到达。
以分布式邮件数据库系统为例。每个用户的邮箱可能分布式地复制在多台机器上。邮件可能被插入任何一个位置的邮箱。但是，数据更新是以一种懒惰的方式传播的。假设用户在杭州读取了他的邮件（假定只读取邮件不会影响其他邮箱，也就是说，消息不会被删除，甚至不会被标记为已读），当用户飞到惠州后，单调读一致性可以保证当他在惠州打开他的邮箱时，邮箱中仍然有杭州邮箱里的那些消息。
#### 2．单调写一致性（Monotonic-write Consistency）
跟单调读相似，如果一个进程写一个数据 x，那么它在本地或迁移到别的地方再进行写操作的时候，原来的写操作必须先传播到这个位置。也就是说，进程要在任何地方至少和上一次写一样新的数据。
#### 3．读写一致性（Read-your-writes Consistency)
读写一致性指一个进程对于数据x的写操作，进程无论到任何副本上都应该能被后续读操作看到这个写操作的影响，也就是看到写操作的影响或更新的值。也就是说，写操作总是在同一个进程执行的后续读操作之前完成的，而不管这个后续读操作发生在什么位置。
#### 4．写读一致性（Writes-follow-reads Consistency)
顾名思义，写读一致性就是在读操作后面的写操作基于至少跟上一次读出来一样新的值。也就是说，如果进程在地点1读了x，那么在地点2要写x的副本的话，至少写的时候应该基于和地点1读出的一样新的值。举个例子，用户先读了文章A，然后他回复了一篇文章B。为了满足读写一致性，B被写入任何副本之前，需要保证A必须已经被写入那个副本。即，当原文章存储在某个本地副本上时，该文章的回应文章才能被存储到这个本地副本上。

## 1.5 容错性
分布式系统区别于集中式系统的一个特性是它容许部分失效。它可以从部分失效中自动恢复，而且不会严重地影响整体性能。
### 1.5.1 基本概念
容错往往与可靠的系统紧密相关，而可靠的系统需要满足以下要求。
- 可用性（Availability）：用来描述系统在给定时刻可以正确地工作。
- 可靠性（Reliability）：指系统可以无故障地连续运行。与可用性相反，可靠性是根据时间间隔而不是任何时刻来进行定义的。如果系统在每小时中崩溃的时间为1ms，那么它的可用性就超过99.9999%，但它还是高度不可靠的。与之相反，如果一个系统从来不崩溃，但是要在每年8月停机两个星期，那么它是高度可靠的，但是它的可用性只有98%。因此，这两种属性并不相同。
- 安全性（Safety）：指系统在偶然出现故障的情况下能正确操作而不会造成任何灾难。
- 可维护性（Maintainability）：发生故障的系统被恢复的难易程度。容错，意味着即使系统发生了故障，还能正常提供服务。

### 1.5.2 故障分类
故障通常被分为三类。
- 暂时故障（Transient Fault）：只发生一次，然后就消失了，不再重现该故障。
- 间歇故障（Intermittent Fault）：发生，消失不见，而后再次发生，如此反复进行。
- 持久故障（Permanent Fault）：那些直到故障组件被修复之前持续存在的故障。

分布式系统中的典型故障模式可以分为以下几种。
- 崩溃性故障（Crash Failure）：服务器停机，但是在停机之前工作正常。
- 遗漏性故障（Omission Failure）：服务器不能响应到来的请求。可以细分为服务器不能接收到来的消息，以及服务器不能发送消息。
- 定时性故障（Timing Failure）：服务器对请求响应得过快或者过慢。
- 响应性故障（Response Failure）：服务器对请求以错误的方式进行了响应。
- 任意性故障（Arbitrary Failure）：服务器可能在任意的时间产生任意类型的故障。其中，任意性故障是最严重的故障，也称为拜占庭故障（Byzantine Failure）。当发生故障时，服务器可能产生它从来没有产生过的输出，但是又不能检测出错误。更坏的情况是，发生故障的服务器与其他服务器共同工作来产生恶意的错误结果。Windows系统“蓝屏”正是为了尽可能避免这种情况而设计的。这种情况也说明了为什么谈到可靠系统时安全被认为是一个重要的需求。

### 1.5.3 使用冗余来掩盖故障
如果系统是容错的，那么它能做的最好的事情就是对其他进程隐藏故障。关键技术是使用冗余来掩盖故障。有三种可能：信息冗余、时间冗余和物理冗余。

### 1.5.4 分布式提交
在分布式系统中，事务往往包含多个参与者的活动，单个参与者的活动是能够保证原子性的，而保证多个参与者之间原子性则需要通过两阶段提交或三阶段提交算法实现。
#### 两阶段提交
两阶段提交协议（Two-phase Commit Protocol,2PC）的过程涉及协调者和参与者。协调者可以看作事务的发起者，同时是事务的一个参与者。对于一个分布式事务来说，一个事务是涉及多个参与者的。两阶段提交的具体过程如下。
##### 第一阶段 准备阶段
1. 协调者节点向所有参与者节点询问是否可以执行提交操作（vote），并开始等待各参与者节点的响应。
2. 与者节点执行所有事务操作，并将Undo信息和Redo信息写入日志（注意：若成功这里其实每个参与者已经执行了事务操作）。
3. 各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个“同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个“中止”消息
##### 第二阶段 提交阶段
第二阶段（提交阶段）如果协调者收到了参与者的失败消息或超时，则直接给每个参与者发送回滚（rollback）消息；否则，发送提交（commit）消息；参与者根据协调者的指令执行提交或回滚操作，释放所有事务处理过程中使用的锁资源（注意：必须在最后阶段释放锁资源）。
- 当协调者节点从所有参与者节点处获得的相应消息都为“同意”时：
    - 协调者节点向所有参与者节点发出“正式提交（commit）”的请求。
    - 参与者节点正式完成操作，并释放在整个事务期间内占用的资源。
    - 参与者节点向协调者节点发送“完成”消息。
    - 协调者节点收到所有参与者节点反馈的“完成”消息后，完成事务。
- 如果任一参与者节点在第一阶段返回的响应消息为“中止”，或者协调者节点在第一阶段的询问在超时之前无法获取所有参与者节点的响应消息时：
    - 协调者节点向所有参与者节点发出“回滚操作（rollback）”的请求。
    - 参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间占用的资源。
    - 参与者节点向协调者节点发送“回滚完成”消息。
    - 协调者节点收到所有参与者节点反馈的“回滚完成”消息后，取消事务。
##### 优缺点
优点：原理简单，实现方便。
缺点:
- 同步阻塞问题。在执行过程中，所有参与节点都是事务阻塞型的。
- 单点故障。由于协调者的重要性，一旦协调者发生故障，参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者都还处于锁定事务资源的状态，而无法继续完成事务操作。
- 数据不一致。在阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常，或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接收到了commit请求。而在这部分参与者接收到commit请求之后就会执行commit操作，但是其他部分未接收到commit请求的机器则无法执行事务提交操作。于是整个分布式系统便出现了数据不一致性的现象。
- 两阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了，那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否已经被提交。
#### 三阶段提交
三阶段提交协议（Three-phase Commit Protocol,3PC）是两阶段提交（2PC）的改进版本。与两阶段提交相比，三阶段提交有两点改动：
- 引入超时机制，同时在协调者和参与者中都引入超时机制。
- 在第一阶段和第二阶段中插入一个准备阶段，保证在最后提交阶段之前各参与节点的状态是一致的。
##### CanCommit阶段
CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回yes响应，否则返回no响应。
- 事务询问：协调者向参与者发送CanCommit请求，询问是否可以执行事务提交操作，然后开始等待参与者的响应。
- 响应反馈：参与者接收到CanCommit请求之后，在正常情况下，如果其自身认为可以顺利执行事务，则返回yes响应，并进入预备状态，否则返回no响应。
##### PreCommit阶段
协调者根据参与者的反应情况来决定是否执行事务的PreCommit操作。根据响应情况，有以下两种可能。
- 假如协调者从所有的参与者处获得的反馈都是yes响应，那么就会执行事务的预执行。
    - 发送预提交请求：协调者向参与者发送PreCommit请求，并进入Prepared阶段。
    - 事务预提交：参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。
    - 响应反馈：如果参与者成功地执行了事务操作，则返回ACK响应，同时开始等待最终指令。
- 假如任何一个参与者向协调者发送了no响应，或者等待超时之后，协调者都没有接收到参与者的响应，那么就执行事务的中断操作。
- 发送中断请求：协调者向所有参与者发送abort请求。
- 中断事务：参与者接收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请），执行事务的中断操作。
##### doCommit阶段
该阶段进行真正的事务提交，也可以分为以下两种情况。
- 执行提交
    - 发送提交请求：协调者接收到参与者发送的ACK响应，那么它将从预提交状态进入提交状态，并向所有参与者发送doCommit请求。
    - 事务提交：参与者接收到doCommit请求之后，正式进行事务提交，并在完成事务提交之后释放所有事务资源。
    - 响应反馈：事务提交完之后，向协调者发送ACK响应。
    - 完成事务：协调者接收到所有参与者的ACK响应之后，完成事务。
- 中断事务：协调者没有接收到参与者发送的ACK响应（可能是接收者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务操作。
    - 发送中断请求：协调者向所有参与者发送abort请求。
    - 事务回滚：参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。
    - 反馈结果：参与者完成事务回滚之后，向协调者发送ACK消息。
    - 中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断操作。
在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或rebort请求，则会在等待超时之后，继续进行事务的提交。即当进入第三阶段时，由于网络超时等原因，虽然参与者没有接收到commit或abort响应，事务仍然会提交。
三阶段提交不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，如果协调者发送的abort响应由于网络原因没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作，这样就和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况。
#### Paxos算法
Paxos算法是Leslie Lamport于1990年提出的一种基于消息传递且具有高度容错特性的一致性算法。Paxos算法目前在Google的Chubby、MegaStore、Spanner等系统中得到了应用，Hadoop中的ZooKeeper也使用了Paxos算法。
在Paxos算法中有4种角色:● Proposer：提议者；● Acceptor：决策者；● Client：产生议题者；● Learner：最终决策学习者。
##### 执行过程
阶段1:
- Proposer：选择一个议案编号n，向Acceptor的多数派发送编号也为n的prepare请求。
- Acceptor：如果接收到的prepare请求的编号n大于它已经回应的任何prepare请求，则它就回应已经批准的编号最高的议案（如果有的话），并承诺不再回应任何编号小于n的议案。

阶段2
- Proposer：如果收到了多数Acceptor对prepare请求（编号为n）的回应，则它就向这些Acceptor发送议案{n,v}的accept请求，其中v是所有回应中编号最高的议案的决议，或者是Proposer选择的值，如果响应中不包含议案，那么它就是任意值。
- Acceptor：如果收到了议案{n, v}的accept请求，则它就批准该议案，除非它已经回应了一个编号大于n的议案。
- Proposer可以提出多个议案，只要它遵循上面的算法。它可以在任何时刻放弃一个议案（这不会破坏正确性，即使在议案被放弃后议案的请求或回应消息才到达目标）。如果其他Proposer已经开始提出更高编号的议案，那么最好能放弃当前的议案。因此，如果Acceptor忽略一个prepare或accept请求（因为已经收到了更高编号的prepare请求），则它应该告知Proposer放弃议案。这是一个性能优化，而不影响正确性

## 1.6 CAP理论
### 1.6.1 什么是CAP理论?
在计算机科学理论中，CAP理论（也称为Brewer定理）是由计算机科学家Eric Brewer在2000年提出的，其理论观点是，在分布式计算机系统中不可能同时提供以下三个保证。
- 一致性（Consistency）：所有节点同一时间看到的是相同的数据。
- 可用性（Availability）：不管是否成功，确保每一个请求都能接收到响应。
- 分区容错性（Partition Tolerance）：将系统任意分区后，在网络故障时，仍能操作。

![76947-lojggdqr3t.png](http://www.sukidesu.top/usr/uploads/2020/10/320732975.png)

### 1.6.2 为什么CAP只能三选二?
图显示了在一个网络中，N1和N2两个节点共享数据块V，其中有一个值V0。运行在N1上的A程序可以认为是安全、无bug、可预测和可靠的。运行在N2上的是B程序。在这个例子中，A将写入V的新值，而B从V中读取值。
![示例](http://www.sukidesu.top/usr/uploads/2020/10/3634306562.png)
系统预期执行的操作如图所示。
![系统预期执行的操作](http://www.sukidesu.top/usr/uploads/2020/10/3205094425.png)

1. 写一个V的新值V1。
2. 消息（M）从N1更新V的副本到N2。
3. 从B读取返回的V1。

如果网络是分区的，当N1到N2的消息不能传递时，执行图中的第三步，会出现虽然N2能访问V的值（可用性），但其实与N1的V的值已经不一致了（一致性）的情况。

### 1.6.3 CAP常见模型
既然CAP理论已经证明了一致性、可用性、分区容错性三者不可能同时达成。那么在实际应用中，可以在其中的某一些方面来放松条件，从而达到妥协。下面是常见的三种CAP模型。
1.牺牲分区（CA模型）
牺牲分区容错性意味着把所有的机器搬到一台机器内部，或者放到一个“要死大家一起死”的机架上（当然机架也可能部分失效），这明显违背了我们希望获得的可伸缩性。
CA模型常见的例子：● 单站点数据库；● 集群数据库；● LDAP；● xFS文件系统。
实现方式：● 两阶段提交；● 缓存验证协议。
2.牺牲可用性（CP模型）
牲可用性意味着一旦系统中出现分区这样的错误，则系统直接停止服务。
CP模型常见的例子：● 分布式数据库；● 分布式锁定；● 绝大部分协议。
实现方式：● 悲观锁；● 少数分区不可用。
3．牺牲一致性（AP模型）
AP模型常见的例子：● Coda；● Web缓存；● DNS。
实现方式：● 到期/租赁；● 解决冲突；● 乐观。

### 1.6.3 CAP发展
理解CAP理论最简单的方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据的一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，但这又会导致丧失P性质。一般来说，跨区域的系统，架构师无法舍弃P性质，就只能在数据一致性和可用性上做一个艰难的选择。不确切地说，NoSQL运动的主题其实是创造各种可用性优先、数据一致性其次的方案；而传统数据库坚守ACID特性，做的是相反的事情。

Eric Brewer在2012年发表文章[插图]指出了CAP里面“三选二”的做法存在一定的误导性，主要体现在：
1. 由于分区很少发生，在系统不存在分区的情况下没什么理由牺牲C或A；
2. C与A之间的取舍可以在同一系统内以非常细小的粒度反复发生，而每一次的决策可能因为具体的操作，乃至因为牵涉特定的数据或用户而有所不同；
3. 这三种性质都可以在一定程度上衡量，并不是非黑即白的有或无。可用性显然是在0%到100%之间连续变化的。一致性分很多级别，连分区也可以细分为不同含义，如系统内的不同部分对于是否存在分区可以有不一样的认知。

## 1.7 安全性
计算机的安全性通常包括两个部分：认证和访问控制。认证包括对有效用户身份的确认和识别。而访问控制则致力于避免对数据文件和系统资源的有害篡改。
// 浏览,暂未做笔记

# 第2章 分布式系统架构体系
## 2.1 基于对象的体系结构
分布式对象之所以成为重要的范型，是因为它相对比较容易地把分布的特性隐藏在对象接口后面。因为对象实际上可以是任何事务，所以它也是构建系统的强大范型。
### 2.1.1 分布式对象
一个对象可能实现多个接口，给定的一个接口定义可能有多个对象为其提供实现。把接口与实现这些接口的对象进行分隔，对于分布式系统是至关重要的。严格的隔离允许我们把接口放在一台机器上，而使对象本身驻留在另外一台机器上。这种组织通常称为分布式对象
![带有客户端代理的远程对象的常见组织](http://www.sukidesu.top/usr/uploads/2020/10/3228867128.png)
当客户绑定（bind）到一个分布式对象时，就会把这个对象的接口的实现——称为代理（proxy）——加载进客户的地址空间中。服务器端存根通常被称为骨架（skeleton），因为它提供了明确的方式，允许服务器中间件访问用户定义的对象。
大多数分布式对象的一个特性是它们的状态不是分布式的。状态驻留在单台机器上，在其他机器上，智能地使用被对象实现的接口，这样的对象也被称为远程对象（remote object）。分布式对象的状态本身可能物理地分布在多台机器上，但是这种分布对于对象接口背后的客户来说是透明的。
### 2.1.2 Java RMI
Java在最初只支持通过socket来实现分布式通信。JavaRMI允许程序员在创建分布式应用程序时，可以从其他Java虚拟机（JVM）调用远程对象的方法。Java RMI在概念上类似于RPC(谁能用通俗的语言解释一下什么是 RPC 框架？ - 洪春涛的回答 - 知乎
https://www.zhihu.com/question/25536695/answer/221638079)，但能在不同地址空间支持对象调用的语义。

## 2.2 面向服务的架构(SOA)
SOA体系结构（Service Oriented Architecture，面向服务的架构）基于服务组件模型，将应用程序的不同功能单元（称为服务）通过定义良好的接口契约联系起来，接口是采用中立方式进行定义的，独立于实现服务的硬件平台、操作系统和编程语言，使得构建在这样系统中的服务可以以一种统一的、通用的、灵活的方式进行交互。
![SOA架构的组成](http://www.sukidesu.top/usr/uploads/2020/10/1842813321.png)

## 2.3 REST风格的架构
### 2.3.1 什么是REST
REST（REpresentation State Transfer，表述性状态转移）描述了一个架构样式的网络系统，比如Web应用程序。REST并非标准，而是一种开发Web应用的架构风格，可以将其理解为一种设计模式。REST基于HTTP、URI及XML这些现有的广泛流行的协议和标准，伴随着REST的应用，HTTP协议得到了更加正确的使用。
## 2.3.2 REST有哪些特征?
REST指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是REST。
基于REST的Web服务遵循一些基本的设计原则，使得RESTful应用更加简单、轻量，开发速度也更快：
1. 通过URI标识资源——系统中的每一个对象或资源都可以通过唯一的URI进行寻址，URI的结构应该简单、可预测且易于理解，比如定义目录结构式的URI。
2. 统一接口——以遵循RFC-2616所定义的协议的方式显式地使用HTTP方法，建立创建、检索、更新和删除（CRUD:Create、Retrieve、Update和Delete）操作与HTTP方法之间的一对一映射。
3. 资源多重表述——URI所访问的每个资源都可以使用不同的形式加以表示（比如XML或JSON），具体的表现形式取决于访问资源的客户端，客户端与服务提供者使用一种内容协商的机制（请求头与MIME类型）来选择合适的数据格式，最小化彼此之间的数据耦合。
4. 无状态——对服务器端的请求应该是无状态的，完整、独立的请求不要求服务器在处理请求时检索任何类型的应用程序上下文或状态。

## 2.4 微服务架构(MSA)
微服务架构风格就像是把小的服务开发成单一应用的形式，运行在其自己的进程中，并采用轻量级的机制进行通信（一般是HTTP资源API）。这些服务都是围绕业务能力来构建的，通过全自动部署工具来实现独立部署。这些服务可以使用不同的编程语言和不同的数据存储技术，并保持最小化集中管理。

## 2.5 容器技术
容器具有轻量级特性，所需的内存空间较少，提供非常快的启动速度，而虚拟机提供了专用操作系统的安全性和更牢固的逻辑边界。
容器提供了更高级的隔离机制，许多应用程序在主机操作系统下运行，所有应用程序共享某些操作系统库和操作系统的内核。
容器和虚拟机都具有高度可移植性.
容器的一大好处就是应用程序以标准方式进行格式化之后才放到容器中。
