---
layout: post
cid: 128
title: 读书笔记： 编码：隐匿在计算机软硬件背后的语言
slug: 128
date: 2021/11/16 08:42:00
updated: 2022/04/22 17:40:37
status: publish
author: AntiTopQuark
categories: 
  - 读书笔记
tags: 
  - 类型
  - 逻辑
  - 缓冲
  - 方法
  - 语言
  - 逃逸
  - 系统
  - 扩展
  - 定律
  - 状态
  - 任务
  - 操作
  - 笔记
  - 机器
  - 编码
  - class
  - 过程
  - 原理
  - set
  - 缩写
  - 字符
  - 标记
  - 章
  - 优先
  - sum
  - 知识
  - 大写
  - 上下文
  - 计算
  - 黑夜
  - 问题
  - 题目
  - 密码
  - 输入
  - 内容
  - 工作
  - 作者
  - 继电器
  - 二进制
  - 法器
  - 二进制数
  - 符号
customSummary: 
mathjax: auto
noThumbInfoStyle: default
outdatedNotice: no
pp_isEnabled: 0
pp_passwords: 
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---


# 读书笔记： 编码：隐匿在计算机软硬件背后的语言

## 第一章 至亲好友

编码这个词的意思是指一种用来在机器和人之间传递信息的方式。换句话说，编码就是交流。

问题的关键就在于**数字2**。两种闪烁，两种声音。事实上，两个不同的事物，只要经过适当的组合，就可以表示所有类型的信息，这的确是千真万确的。

**本章小结**

在本章中，我们带入小男孩的视角，想在黑夜中与街对面的朋友进行交流，本章给出了一种解决的方法，就是使用手电筒和摩尔斯电码来交流。莫尔斯电码是使用“点”和“划”来进行编码的。事实上，这种二进制的编码方式可以表示出所有的信息。

## 第二章 编码与组合

**本章小结**

作者从莫尔斯的解码引入，从而讲述了莫尔斯密码是如何计算总共有多少个组合的。由于莫尔斯码是一种二进制码，在计算的时候实际上就是2的n次幂。这一章是给没啥数学基础的小孩子讲的。

## 第三章 布莱叶盲文与二进制码

这64组编码中有很大一部分，根据上下文的不同将有着双重身份。

尤其值得注意的是数字标识符和取消“数字标识状态”的字母标识符。它们改变了后面编码的意义——从表示字母到表示数字，又从表示数字回到表示字母。像这样的编码通常被称作“优先码”（precedence codes）或者“换档码”（shift codes）。它们改变着作用域内编码的含义，直到作用域结束。(*优先码是有开始有结束*)

大写字母标识符表示紧随它的字母（而且仅仅是紧随它的字母）应该被译为大写。类似这样的编码被称为“逃逸码”（escape codes）。逃逸码让你“逃离”对编码串单调的、一成不变的解析，而转入一种新的解析方式中。(*逃逸码是仅仅只有它后面的字母逃逸*)

**本章小结**

布莱叶盲文使用了2*3的点位来表示一个字母，所以总共有64个编码。除去26个字母和10个数字之外，布莱叶盲文设计了很多的缩写、重音、以及大写标识符、数字标识符等等。其中有一定作用域范围的是“优先码”或者“换挡码”；影响力仅仅只有后面一个字母的是叫“逃逸码”

## 第四章 手电筒的剖析

**本章小结**

本章用电灯泡来引入，先介绍了一下原子、电子和电流，之后又介绍了电路的相关知识：电压、电流、电阻以及电流热效应。这也是一些初中的知识。让我们进入到下一章。

## 第五章 绕过拐角的通信

**本章小结**

本章我们又回到12岁小男孩的视角，我们现在需要和相邻房子的朋友建立起一个通讯线路来。之前我们已经学习了手电筒的内部原理。所以我们可以在两个房子之间搭建起两条手电筒电路出来。然后使用开关的开或者合来产生相应的光，使用莫尔斯电码通讯。聪明的我们可以对电路进行改进，使用公用链接的方式或者接地的方式来节省导线。

## 第六章 电报机与继电器

发声器中的电磁铁拉动上面的活动横杠下降，它会发出“滴”的声音。当松开电键的时候，横杠弹回到原来的位置，发出“嗒”的声音。一次快速的“滴-嗒”声代表点；一次慢速的“滴——嗒”声则代表划。

![image-20210925215219077](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210925215219077.png)

**本章小结**

莫尔斯不光发明了莫尔斯码，还发明了电报机和继电器。简单来说，就是使用电流的磁效应，来带动金属杆。而继电器就是在超远程线路的中间使用金属杆来控制另一个线路。从而使新的线路产生相同的编码。

## 第七章 我们的十个数字

**本章小结**

本章也很基础，介绍了一下十进制。重点介绍了基于位置计数的阿拉伯数字。为下一章的二进制打下基础。

## 第八章 十的代替品

**本章小结**

本章也很基础+1，本章是承接了上一章，介绍了八进制、四进制和二进制。

## 第九章 二进制数

二进制数字系统存在一点特殊性。这个特殊性就在于它是人们所能得到的最简单的数字系统。二进制数字系统中只有两个数字——0和1。

在计算机时代，比特被看做是组成信息块的基本单位。

1比特是可能存在的最小的信息量。任何小于1比特的内容都根本算不上是信息。由于1比特表示的是可能存在的最小信息量，那么复杂一些的信息就可以用多位二进制数来表达

信息是指多个可能性中的一种。

所有可以被转换成对两种或多种可能性的选择的信息，都可以用比特来表示。

利用二进制表示信息的一个额外的好处就是我们可以清楚地知道我们是否已经想到了所有的可能性。

比特在逻辑学中也很重要。逻辑学是哲学和数学的奇特融合，其主要目的就是确定某个陈述是真还是假。真和假同样可以表示为1和0

**本章小结**

本章是承接了上一章，介绍了二进制为什么特殊，为什么很重要。二进制是最小的进制了，但是小小的0和1却可以表示出无限的信息。

## 第十章 逻辑与开关

亚里士多德的逻辑学基础是三段论法

布尔发明了一种代数。在布尔代数（Boole’s algebra，现在也这样叫）中，操作数不是数字而是类（class）。简单说，一个类就是一个事物的群体，它后来也被称为集合（set）。布尔代数中使用“∪”和“∩”来代表并集和交集

**本章小结**

这一章主要是介绍了一下布尔代数，布尔代数的操作数是集合。它的操作有交集、并集、补集、差集等等。同时，布尔代数可以和电路的串联、并联联系起来。用灯泡的亮和暗来代表最终结果，这也是一个二进制的体现。

## 第十一章 门

1938年，香农在麻省理工学院完成了那篇题为《继电器和开关电路的符号分析》（A Symbolic Analysis of Relay and Switching Circuits）的著名硕士论文，在文中阐述了这个问题（10年之后，他又发表了论文“通信的数学原理”，即The Mathematical Theory ofCommunication，这是第一篇使用“bit”这个词来表示二进制数字的文章）。

继电器像开关一样，可以串联或并联在电路中执行简单的逻辑任务。这种继电器的组合叫做逻辑门（logic gates）。

这里提到的逻辑门执行“简单”逻辑任务是指逻辑门只完成最基本的功能。继电器优于开关之处就在于，继电器可以被其他继电器所控制，而不必由人工控制。这就意味着，这些简单的逻辑门组合起来可以实现更复杂的功能，例如一些简单的算术操作。

当电磁铁将金属簧片拉下来时，我们称继电器被“触发”（triggered）。当左边的开关断开的时候，铁芯的磁性消失，金属簧片回到原位。![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927002307764.png)

连接继电器是建立逻辑门的关键。两个开关可以串联，同样地，两个继电器也可以串联。只有两个开关都闭合的时候灯泡才会被点亮。这样的两个继电器串联被称为一个”与门“。同样也可以有三个继电器并联，这样的叫做三与门。![image-20210927002826006](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927002826006.png)![image-20210927002923844](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927002923844.png)

除了继电器串联在一起意外，继电器之间还可以并联在一起，即任意一个继电器通电，输出都会通电。我们叫它"或门"。![image-20210927003134894](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927003134894.png)![image-20210927003146476](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927003146476.png)

还有一种，开关闭合灯泡熄灭，开关打开灯泡亮起来。这种叫做反向器（inverter）。反向器不是逻辑门（一个逻辑门通常有两个或者多个输入），但是反向器用途很广泛，我们也可以叫他“非门”。![image-20210927003421036](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927003421036.png)

在连接门和反向器的时候有一些规则，影响它们的连接方式：一个门（或反向器）的输出可以作为一个或多个其他门（或反向器）的输入。但是两个或多个门（或反向器）的输出是不可以相互连接的。

恰恰与或门相反，这个门称为“或非门”，简称NOR，用以下符号表示。除去输出部分的小圆圈，这个符号与或门非常相像。小圆圈表示“反向”.![image-20210927003659092](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927003659092.png)

这种逻辑门被称为与非门，或简称NAND。与非门的符号和与门类似，但在输出部位多了一个小圆圈，意思是输出和与门正好相反。![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927003730910.png)

这叫做缓冲器（buffer），可用如下符号表示。除了输入端的小圆圈，这个符号与反向器是很相似的。很明显，缓冲器“没有什么作用”，它的输入与输出是相同的。但是在输入信号很微弱的时候，缓冲器就可以派上用场。另外，缓冲器还可以用于延迟一个信号。这是因为继电器需要一点时间——几分之一秒——才会被触发。![image-20210927003842408](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927003842408.png)

实际上，带有两个反向输入的与门和或非门是等价的。类似的，带有两个反向输入的或门和与非门也是等价的。这两组等价关系就是摩根定律在电路中的实现。![image-20210927004053150](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927004053150.png)![image-20210927004102599](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927004102599.png)![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210927004037292.png)

摩根定律是简化布尔表达式的一种重要手段，因此也可以用来简化电路。

**本章小结**

本章还是用继电器的引入，使用继电器实现了各种门。例如与门、或门、非门、与非门、或非门。最后又介绍了一下摩根定律。摩根定律也是简化布尔表达式的重要手段。现在我们就可以使用继电器来构建自己的计算机了~

## 第十二章 二进制加法器

**加法是算术运算中最基本的运算**，因此如果想搭建一台计算机。那么首先就要造出可以计算两个数的和的器件。

当你真正面对它时，就会发现，原来**加法计算就是计算机要做的唯一工作。如果我们可以造出加法器，同样地，就可以利用加法来实现减法、乘法和除法**

一对二进制数相加的结果中具有两个数位，其中一位叫做加法位（sum bit），另一位则叫做进位位（carry bit，例如，1加1等于0，进位为1）。

在我们的加法器中加法与进位是分别进行的。利用与门可以计算两个二进制数加法的进位。利用异或门，简写是XOR可以得到加法位。

在整个电路中仍然有两个输入和一个输出。两个输入同时作为或门和与非门的输入。或门和与非门的输出又分别作为一个与门的输入，这种叫做异或门。![image-20211001193240646](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20211001193240646.png)

两个二进制数相加的结果是由异或门的输出给出的，而进位位是由与门的输出给出的。因此我们可以将与门和异或门连在一起来计算两个二进制数（即A和B）的和。

这个叫做半加器（Half Adder）之所以叫半加器是因为，它将两个二进制数相加，得出一个加法位和一个进位位。但是绝大多数二进制数是多于1位的。半加器没有做到的是将之前一次的加法可能产生的进位位纳入下一次运算。![image-20211001193432267](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20211001193432267.png)

首先从最左边第一个半加器的输入A和输入B开始，其输出是一个加和及相应的进位。这个和必须与前一列的进位输入相加，然后再把它们输入到第二个半加器中。第二个半加器的输出和是最后的结果。两个半加器的进位输出又被输入到一个或门中。你可能会觉得，这里还需要一个半加法器，这当然是可行的。但是如果你了解了所有的可能性之后，你会发现，两个半加法器的进位输出是不会同时为1的。或门在这里已经足够，因为或门除了在输入都为1的时候以外，其他情况下结果和异或门结果相同。![image-20211001193556342](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20211001193556342.png)

为了避免重复地画上面的那个图，我们用以下形式来替代上图中的一堆符号，它称为全加器（Full Adder）。![image-20211001193606709](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20211001193606709.png)

下面是画成一个盒子的完整的8位二进制加法器，输入标记为A0～A7和B0～B7，输出标记为S0～S7。A0、B0和S0是最低有效位，或者说是最右边的一位。A7、B7和S7是最高有效位，或者说是最左边的一位。![image-20211001193650760](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20211001193650760.png)另一种8位二进制加法器可用下图表示。![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20211001193823224.png)

一旦你搭建起了8位二进制加法器，你就可以再搭建另外一个加法器。把它们级联起来就可以很容易地扩展出一个16位加法器。![image-20211001193850147](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20211001193850147.png)

加法器的总体速度等于数字的位数乘以全加器器件的速度，这被称做行波进位（ripple carry，或脉冲进位）。更快的加法器运用了一个被称为“前置进位”的电路来提高运算的速度。

**本章小结**

本章主要讲述了使用逻辑门可以实现二进制的加法。两个二进制数相加的结果是由异或门的输出给出的，而进位位是由与门的输出给出的，我们就可以简单地实现一个半加器。两个半加器就可以把进位也纳入到计算中，形成一个全加器。有了全加器就可以实现8位2进制的全加器。就可以进行无限的扩展了。

而加法也是计算机计算的基础。后续的减法、乘法、除法其实都是根据加法来做的。

## 第十三章 如何实现减法

为了便于表达，将进行减法的两个数分别用被减数（minuend）和减数（subtrahend）表示。从被减数中减去减数，得到的结果叫做差（difference）。

为什么这种方法行得通呢？
原题目是这样的：
253- 176
在这个式子中加上一个数再减去这个数，结果是相同的。因此先加上1000，再减去1000：
253- 176 + 1000 - 1000
这个式子与下式等价：
253- 176 + 999 + 1 - 1000
然后用以下方式将数字重新组合：
253 + (999 - 176) + 1 - 1000
这就是一个求补码的过程

求补码在二进制中同样很有用，在二进制数减法中，减数是从一串1中减去的，结果称为1的补数。

**我们在求对1的补数时并不需要用到减法。在求对1的补数时，只需将原来的二进制数中的1变为0，将0变为1即可。因此对1求补数有时也会称为相反数（negation）或反码（inverse）**。这里你可能会想起第11章中的反向器，它的作用就是将0变为1，将1变为0。

**所以二进制减法的计算过程是：第一步，用11111111（即255）减去减数；第二步，将减数对1的补数与被减数相加；第三步，将上式所得结果加1；第四步，减去100000000（即256）：**

加法器中新增的主要部分就是一个用来求8位二进制数对1补数的电路。之前提到，二进制数对1求补数相当于对其每位取反，因此我们计算8位二进制数补数的时候可以简单地应用8个反向器。将8个异或门合并起来画成一个器件，称为求补器（One’sComplement），如下所示。

无符号的8位二进制数所表示的范围是0～255。有符号的8位二进制表示的范围是-128～127。无论是有符号的还是无符号的，数字本身是无法显示的。有符号现在所表示的数的范围是-128～+127。**最高有效位（最左位）作为符号位（sign bit）。符号位中，1表示负数，0表示正数。**

![image-20211001200006617](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20211001200006617.png)

**本章小结**

本章介绍了二进制减法的计算和减法器的原理。二进制减法实际上就是使用加法结合律，**第一步，用11111111（即255）减去减数；第二步，将减数对1的补数与被减数相加；第三步，将上式所得结果加1；第四步，减去100000000（即256）；**减法器实际上就是把上述过程给实现了。然后介绍了一下有符号数和无符号数。**最高有效位（最左位）作为符号位（sign bit）。符号位中，1表示负数，0表示正数。**

## 第十四章 反馈与触发器

![image-20211001200736522](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20211001200736522.png)

开关一旦闭合，金属簧片就会上下跳动——电路也会随之连通或断开——声音也就会随之发出。如果金属簧片发出了一种刺耳的声音，这套系统就成为了一个蜂鸣器。如果金属簧片前端是一把小锤子，旁边只要放上一个锣，就构成了一个电铃。![image-20211001200816653](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20211001200816653.png)

这个图可能看起来有一些逻辑矛盾，但是继电器在进行开关的开闭的时候，总会有一些时差的。所以就产生了频繁的开关闭合和打开。

我们把这种电路称为**振荡器**（oscillator）。在此之前我们讲过的所有的电路，其状态的改变都依靠人为的干预，通常是通过改变开关状态来实现的。但是振荡器却在不需要人干涉的情况下，可以完全自发地工作。

![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609224.png)
这幅图表示随着时间的推移，振荡器的输出在0和1之间按照固有的规律交替变化。正因为这一点，振荡器又经常被称为时钟（clock），通过振荡进行计数也是一种计时方式。

让我们先来看看采用特殊方式连接的一对或非门。或非门的特点是只有在两个输入端都没有电压时，输出端才产生电压。
左边或非门的输出是右边或非门的输入，而右边或非门的输出是左边或非门的输入。这种连接方式我们称之为反馈（feedback）。
在初始状态下，电路中只有左边的或非门输出电流，这是因为其两个输入均为0。让我们闭合上面的开关，左边或非门将立刻输出0，右边或非门的输出也会随之变为1，这时灯泡将被点亮。

![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609306.png)
这时一旦你关闭上边的开关，灯炮依然闪闪发光。这是因为由于左边或非门的输入中有一个为1，其输出依然是0，因而左边或非门的输出不变，所以灯泡仍然亮着。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609350.png)
现在来试试闭合下面的开关。我们会发现右边或非门的输入中有一个立刻变为1，其输出就相应地变为0，灯泡随之熄灭。左边或非门的输出此刻变为1。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609394.png)
这时你再去断开下面的开关就会发现，灯泡一直处在熄灭状态。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609416.png)
总结一下：
- 接通上面的开关，灯泡被点亮，断开此开关灯泡仍然亮着。
- 接通下面的开关，灯泡被熄灭，断开此开关灯泡仍然不亮。
同样是在两个开关都断开的状态下，灯泡有时亮着，有时却不亮。当两个开关都断开时，电路有两个稳定态，这类电路统称为**触发器**（Flip-Flop）
触发器电路可以保持信息，它可以“记住”某些信息。特别地，对于本章先前所讲述的触发器，它可以记住最近一次是哪个开关先闭合。如果你遇到这样一种触发器，如果它的灯泡是亮着的，你就可以推测出最后一次连通的是上面的开关；而如果灯泡不亮则可推测出最后一次连通的是下面的开关。


触发器种类繁多，先前所讲述的是最简单的一种**R-S（Reset-Set，复位/置位）触发器**。我们通常把两个非或门绘制成另一种形式，加上标识符就得到了下面这幅图。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609510.png)
通常用Q来表示用于点亮灯泡的输出的状态。另一个输出![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609552.png)（读做Q反）是对Q的取反。Q是0，![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609552.png)就是1，反之亦然。输入端S（Set）用来置位，R（Reset）用来复位。你可以把“置位”理解为把Q设为1，而“复位”是把Q设为0。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609655.png)
这类表称为功能表（function table）、逻辑表（logic table）或真值表（truthtable）。它表达了不同输入组合所对应的不同输出结果。
这一行输入S和R均为0，而输出标识为Q和![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609552.png)。这表示当S和R输入均为0时，Q和![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609552.png)端的输出保持为S、R同时被设为0以前的输出值。表中最后一行表示S和R均为1的输入组合是被禁止或者不合法的。不要误解为你会因此被逮捕，而是说如果S、R状态同时为1时，Q和![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609552.png)均会为零，这与Q和![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609552.png)互反的假设关系相矛盾。所以当使用R-S触发器进行电路设计时，R、S输入同时为1的情况一定要避免。
R-S触发器最突出的特点在于，它可以记住哪个输入端的最终状态为1。但是有时候我们需要一种记忆能力更加强大的电路，例如能记住在某个特定时间点上的一个信号是0还是1。
这个电路存在两个输入。其中一个我们称之为数据端（Data）。与所有数字信号一样，数据端取值为0或1；另一个输入被称为保持位（Hold That Bit），保持位的作用就是使当前的状态被“记住”，通常情况下保持位被设置为0，在这种情况下数据端对电路不产生影响。当保持位置1时，数据端的值就会在电路系统中被“记住”。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609779.png)
使用先前学过的R-S触发器来实现这种具有保持位的功能系统，那么我们的电路需要在输入端增加两个与门，下图所给出了该系统的实现电路。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609829.png)
如果把数据端信号看做置位信号，把它取反后的值看做复位端信号，我们可以画出相应的电路图如下所示。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609972.png)
所有输入均为0，而输出Q也为0（此时[插图]为1）。可以看出只要保持位为0，电路输出就丝毫不受输入端的影响。当保持位为1时，电路反映出数据端输入的值。
**电平触发的D型触发器**，D（Data）表示数据端输入。所谓电平触发是指当保持位输入为某一特定电平（本例中为“1”）时，触发器才保存数据端的输入值（很快，我们将看到另一种形式的触发器）。
输入端是不会被标记为保持位的，而是被标记为时钟（clock）。
它可以在0和1之间有规律地来回变化。但是现在时钟仅仅用来指示什么时候保存数据。这个电路也就是所谓的电平触发的D型锁存器，它表示电路锁存住一位数据并保持它，以便将来使用。


我们在一个小盒子里布置8个锁存器，如前所述，每个锁存器包括两个或非门、两个与门以及一个反相器。所有的时钟输入端都互相连在一起。结果如下图所示。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650610077.png)
这个锁存器可以一次保存8位数。上面的8个输入端依次标记为D0～D7，下面的8个输出端被标记为Q0～Q7。左边的输入是时钟（Clk），时钟信号通常为0。当时钟信号为1时，D端输入的8位值被送到Q端输出。当时钟信号为0时，这8位值将保持不变，直到时钟信号再次被置1。



但是对另外一些应用来说，边沿触发（edge-triggered）时钟输入则更有效。对于边沿触发器而言，只有当时钟从0跳变到1时，才会引起输出的改变。它们的区别在于，在电平触发器中，当时钟输入为0时，数据端输入的任何改变都不会影响输出；而在边沿触发器中，当时钟输入为1时，数据端输入的改变也不会影响输出。只有在时钟输入从0变到1的瞬间，数据端的输入才会影响边沿触发器的输出。
**边沿触发的D型触发器**是由两级R-S触发器按如下方式连接而成的。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650610342.png)
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650610486.png)



把振荡器的输出与边沿触发的D型触发器的时钟端输入连接，同时把[插图]端输出连接到本身的D输入端。这个触发器的输出同时又是它自己的输入。反馈紧接着反馈！
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650610592.png)
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650610607.png)
每当时钟输入由0变为1时，Q端输出就发生变化，或者从0到1，或者由1到0。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650610622.png)
如果这个振荡器的频率是20Hz（即20个周期的时间为1s），那么Q的输出频率是它的一半，即10Hz，由于这个原因，这种电路称为**分频器（frequency divider）**，它的![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650609552.png)输出反馈到触发器的数据端输入D。[插图]输出反馈到触发器

三个分频器连在一起，如下图所示
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650610697.png)
上图顶部的4个信号变化规律如下图所示。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650610720.png)
试着把这个图顺时针旋转90°，然后读一读每一行的4位数字，它们分别对应了十进制中的0～15中的一个数
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650610736.png)
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650610743.png)
这个电路不仅仅具备了一个计数功能。在每一次时钟信号的正跳变时，计数器的输出是增加的，即递增1。把8个触发器连接在一起，然后放入一个盒子中，构成了一个8位计数器。
这个计数器称为“8位行波计数器”，因为每一个触发器的输出都是下一个触发器的时钟输入。变化是在触发器中一级一级地顺序传递的，最后一级触发器的变化必定会有一些延迟，更先进的计数器是“并行（同步）计数器”，这种计数器的所有输出是在同一时刻改变的。
**本章小结**
本章主要讲述了振荡器、触发器（包括RS触发器、电平触发的D触发器、边沿触发的D触发器）、分频器。从而实现了对加法器的数据保存、计数等操作。

## 第十五章 字节与十六进制
这8位比特流就是加法器、锁存器以及数据选择器的输入形式，同时它也是这些器件单元的输出形式。
原始加法机偏偏是8位其实没有什么特别的原因。只不过在每次使用8位位宽时，一切工作都显得非常方便——一种优雅的比特化（biteful）的比特流。
直到20世纪60年代中叶，在IBM的360系统的发展下（一种大规模复杂的商用计算机），字节这个词逐渐开始用来表示一组8比特数据。

字节在很多方面都比单独的比特更胜一筹。IBM采用字节有一个很重要的原因，就是这样一来数字就可以按照BCD形式（第23章中将会讲述）方便地保存。
全世界大部分书面语言（除了中文、日文以及韩文中使用的象形文字体系）的基本字符数都少于256，所以字节是一种理想的保存文本的手段。字节同样适合表示黑白图像中的灰度值，这是由于肉眼能区分的灰度约为256种。
字节的一半——即4比特——我们称之为半字节（nibble，也可拼写成nybble）
两个十六进制数可以完整地代表一个字节。

可以用一个2的补数来表示与其相对应的负数。如果我们处理的是带符号的8位二进制数，那么所有负数的最高位都为1。在十六进制系统中，最高位为8、9、A、B、C、D、E或F的两位带符号数都是负数，因为这些十六进制数对应的二进制数的最高位为1。例如99h可以表示无符号的十进制数153（你必须清楚它是单字节的无符号数），也可以表示十进制的-103（这时它被看做有符号数）。
## 第十六章 存储器组织
习惯于将可能用到的事物先存起来，在需要时将它们取出。从技术角度来讲，这个过程称为先存储后访问。存储器的职责和作用就在于此，它负责保障这两个过程之间信息完好无损。
电平触发的D触发器就可以实现保存数据的功能。

通过某种方式连接8个1位锁存器，使自己能够从一个输入信号端写入数据，还能从一个输出信号端鉴别出数据。现在我们已经成功地使用了一个8-1选择器对8个锁存器进行了选择操作，并将相应锁存器的数据输出，
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650612097.png)

这款元件与8-1选择器功能类似，但它的作用正好相反。我们所说的正是3-8译码器（3-to-8Decoder）。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650612135.png)
译码器和选择器具有相同的选择信号，在上图中这三个信号一起被称为地址端口（Address）。
锁存器在有的资料中也被称为读/写存储器（read/writememory），但更普遍的叫法是随机访问存储器（Random Access Memory），或RAM（和单词animal发音类似）
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650612180.png)
之所以可以被称为随机访问存储器，是因为读写操作很自由，我们只需要改变地址及相关的输入，就可以从8个锁存器中读出或写入需要的数据。
我们把这两个8×1的RAM阵列的地址和输出都分别看成一个整体，这样就得到了一个8×2的 RAM阵列，如下图所示。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650612212.png)
我们还可以把两个8×1的RAM阵列看做是两个锁存器，使用一个2-1选择器和一个1-2译码器就可以把它们按照单个锁存器连接方式进行集成，下面给出了这种方案的电路图。因此这种结构实质上是一种16×1 的RAM阵列，如下图所示。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650612241.png)
RAM阵列的存储容量 = 2\*\*地址输入端的个数
存储容量为1KB的存储系统由8个数据输入端、8个数据输出端和10个地址输入端所组成。
随机访问存储器也被称为易失性（volatile）存储器。为了保证存储的数据不丢失，易失性存储器需要恒定的电流。
## 第十七章 自动操作
在前一章我们使用了大约500万个继电器构造了一个64 KB的RAM阵列。除此之外，我们还把一个控制面板连接到电路帮助我们工作，闭合它的控制（Takeover，有些书中也称“接管”）端开关后，就可以使用其他开关来控制RAM阵列的读写。
用一个16位的计数器（比如我们在14章构造的那种）就可以控制RAM阵列的地址信号。在这个电路中，RAM阵列的数据输入信号和写操作端信号可以省去。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650615346.png)

对于RAM阵列中的每一个数，我们还需要用一些数字代码来标识加法器要做的每一项工作：加载、相加、保存和终止。

也许存放这些代码的最简单的方法（但肯定不是代价最小的）是把它们存放在一个独立的RAM阵列中。这个RAM应该和第一个RAM同时被访问。但是这个RAM中存放的是不需要求和的数，而是一些数字代码，用来标记自动加法器对第一个RAM中指定地址要做的一种操作。这两个RAM可以分别被标记为“数据”（第一个RAM阵列）和“代码”（第二个RAM阵列）。其结构如下图所示。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650615529.png)
代码RAM阵列中存放的每一个代码都对应着数据RAM中要被加载或者加到累加器中的数，或者对应需要存回到数据RAM中的某个数。以这种方式使用的数字代码常常被称为指令码（instruction code）或操作码（operation code，opcode）。它们指示电路要执行的某种操作。

![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650615617.png)

加法器及连接到它的所有设备的宽度只有8位，没有办法处理16位的数据。那么如何实现16位的加法器呢？以前提出过的一个解决办法是把两个8位加法器（其他的大部分设备也用两个）连在一起，构成一个16位的设备。但还有代价更小的解决办法：
这种16位的加法先单独处理最右边的字节（通常称之为低字节），然后再计算最左边的字节，即高字节的和。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650615746.png)
如何保存1位呢？1位锁存器就是最好的选择了，该锁存器应该被称为进位锁存器（Carry latch）。

为了使用进位锁存器，还需要另一个操作码，我们称之为“进位加法”（Add withCarry）。当进行8位数加法时，使用的是常规的Add指令。加法器的进位输入是0，它的进位输出将会保存到进位锁存器（尽管它根本不会被用到）。

如果要对两个16位的数进行加法运算，我们仍然使用常规的Add指令对两个低字节数进行加法运算。加法器的进位输入是0，而其进位输出被锁存到进位锁存器中。当把两个高字节数相加时，要使用新的Add with Carry指令。在这种情况下，两个数相加时要用进位锁存器的输出作为加法器的进位输入。因此，如果第一步低字节数的加法运算有进位，则该进位将用于第二步高字节数的加法运算；如果没有进位，则进位锁存器的输出是0。
如果要进行16位数的减法运算，则还需要一个新的指令，称为“借位减法”（Subtract and Borrow）。

增加了两个新的操作码之后，我们已经极大地扩展了加法器的功能，它不再局限于8位数的加法运算。通过执行进位加法操作，可以对16位数、24位数、32位数、40位数，甚至更多位的数进行加法运算。假如要进行两个32位数7A892BCDh和65A872FFh的加法运算，我们仅需要1条Add指令和3条Add with Carry指令，如下图所示。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650616051.png)

如果我们想让一个程序，算到一半不算了。就需要移除它的一些指令。但是移除之后的指令可能会代价特别大。所以我们可以新增一个Jump指令。指示计算机跳转到哪里。

除此之外，我们还要实现一种条件跳转指令。

![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650616504.png)

到目前位置，我们已经装配了一台计算机了。对上述的操作码进行缩写，就变成了汇编语言。


![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650616643.png)

## 第十八章 从算盘到芯片
人类社会早期： 使用小石头帮助计数
欧洲：演化为计数板，中东演化为算盘
1600年：数学家发明了对数表
1800年：发明了自动织布机
1820年：巴贝芝发明差分器，这是一个大型的机器加法器，但是最终没有实现
1833年：巴贝芝发明了解析机
1930年：发明了继电器
1943年：哈佛大学和IBM发明了一个13000个继电器的计算机
1940年：真空管广泛应用。
1945年：真空管开始完全取代继电器，应用到计算机。年底宾法尼亚大学制作出18000个真空管的计算机——ENIAC
1946年：诺依曼提出了冯诺依曼结构
1947年: 一只飞蛾飞到了计算器里面，导致结果错误。出现了第一个Bug。
20世纪50年代中期，人们发明了磁芯存储器
1947年：贝尔实验室的两个物理学家制作出用半导体元素和黄金制成的放大器，这是第一个晶体管。
1952年：英国物理学家杰里佛：现在也许可以设想将来会出现不采用连线而是由固体块组成的电子设备。这种固体块可能由绝缘层、导体层、整流层以及放大层四个层次组成，将不同层次的隔离区连接起来即可实现电子功能。

集成电路需要经过非常复杂的工艺流程才可以制造出来，包括将硅片分层，然后非常精确地掺入杂质以及蚀刻不同的区域形成微小组件。开发一种新的集成电路尽管很昂贵，但可以大量生产中获得效益——产量越大，价格就越便宜。

1965年：戈登·E·摩尔（Gordon E.Moore，当时在仙童公司工作，后来成为英特尔公司的合伙创办人）发现从1959年以后，技术在以这样一种方式发展：同一块芯片上可以集成的晶体管的数目每年翻一倍。他预测这种趋势将会持续。真实的发展速度比摩尔的发现稍慢一些，因此摩尔定律（最终命名）被修正为：每18个月同一块芯片上集成晶体管数目就会翻一倍。
到1972年4月，英特尔发布了8008芯片——一个时钟频率为200 KHz、可寻址空间为16 KB的8位微处理器（


## 第十九章 两种典型的微处理器
介绍英特尔8008处理器和摩托罗拉6800处理器
## 第二十章 ASCII码和字符转换
概念大致都清楚，先跳过这一张章
## 第二十一章 总线
计算机中各部件按照功能被分别安装在两个或更多的电路板上。这些电路板之间通过总线（bus）通信。总线还可以为计算机上不同电路板供电。
总共有四种总线：
- 地址信号。这些信号是由微处理器产生，通常用来对RAM进行寻址操作，当然也可以用来对连接到计算机的其他设备进行寻址操作。
- 数据输出信号。这些信号也是由微处理器产生的，用来把数据写入到RAM或其他设备。
- 数据输入信号。这些信号是由计算机的其他部分提供的，并由微处理器读取。
- 控制信号。这些信号是多种多样的，通常与计算机内所用的特定的微处理器相对应。控制信号可以产生于微处理器，也可以由与微处理器通信的其他设备产生。




## 第二十二章 操作系统

##  第二十三章 定点数和浮点数
计算机不仅需要存储整数，还需要存储小数。由于计算机中并没有专门的部件对小数中的小数点进行存储和处理，所有需要一种规范，使用二进制数据表示小数。

这种规范分两种：

定点数表示方式
浮点数表示方式
注意：定点数并不是仅仅只能表示整数，定点数也可以表示小数。 浮点数同样可以表示小数和整数；定点数和浮点数只是计算机表示数据的两种不同方式而已。

二、定点数
定点数的意思是：小数点的位置在计算机的存储是约定好的，固定的。一个小数的整数部分和小数部分分别转化为二进制的表示。

例如：十进制的 25.125

整数部分：25使用二进制表示为：11001
小数部分：0.125使用二进制表示为：.001
所以合起来使用11001.001 表示十进制的25.125
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650620371.png)
所以在一个8位的计算机中，前5位表示一个小数的整数部分，后3位表示小数部分，小数点默认是第五位后的位置（实际上计算机不会存储小数点，只是大家这么约定）。

使用11001001表示十进制的25.125。看起来很完美，也很容易理解，但是这么表示没有其他问题吗？

问题：

问题在于：一个8位的计算机，整数部分111111十进制最大只能表示为31 ;小数部分0.111 最大只能表示0.875，

表示的数据范围太小了。当然在16位的计算机中，可以通过增大整数部分位数表示更大的数，增大小数部分的位数可以提高小数精度。但是这种方式对计算机来说开销非常大，所以大多数计算机并没有选择使用定点数表示小数，而是采用浮点数表示小数。

三、浮点数
计算机中使用浮点数表示小数类似于以前数学中用科学计数法表示较大的数。

例如：352.47 = 3.5247 * 10的2次方

178.125转化为二进制为 10110010.001，又可表示为：1.0110010001 乘以 2的111次方（111是7的二进制表示）

10110010001 这部分被称作尾数(M)
111这部分被称作阶码（P）
正负被称作数符（S）: 0表示正数 ， 1表示负数。
那么一个浮点数可以使用三部分表示：数符（S）,阶码（P）,尾数（M）。

根据IEEE754标准，64位计算机的长实数浮点表示。
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650620385.png)



178.125在计算机中使用浮点数表示为：
![](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/04/22/1650620396.png)

四、浮点数与定点数的比较
当相同位数的计算机表示数据（比如64位），浮点数能表示的数据范围远远大于定点数表示的数据范围。
当相同位数的计算机表示数据（比如64位），浮点数的相对精度比定点数要高。
浮点数在计算时，要分阶码部分的计算和尾数部分的计算，而且运算结果要求规格化，故浮点运算步骤比定点数运算步骤多，运算速度比定点运算速度低。
目前大多数计算机使用浮点数表示小数。
## 第二十四章 高级语言与低级语言

## 第二十五章 图形化革命







