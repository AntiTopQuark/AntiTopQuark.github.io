---
layout: post
cid: 149
title: 读书笔记: C/C++ 代码调试的艺术
slug: 149
date: 2022/03/08 20:57:00
updated: 2022/03/15 18:15:40
status: publish
author: AntiTopQuark
categories: 
  - 读书笔记
  - Linux
tags: 
  - print
  - join
  - null
  - 字符
  - str
  - string
  - random
  - else
  - 元组
  - datetime
customSummary: 
mathjax: auto
noThumbInfoStyle: default
outdatedNotice: no
pp_isEnabled: 0
pp_passwords: 
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---


**本书所有的示例代码都可以从异步社区下载。也可以使用Git客户端工具从地址**[**https://github.com/SimpleSoft-2020/book_debug.git**](https://github.com/SimpleSoft-2020/book_debug.git)**下载**

## **第1章 C/C++调试基本知识**

**主要介绍了什么是BUG，以及与调试有关的一些概念，并介绍了调试的重要性**

### **1.1 Bug与Debug**

**BUG:BUG的本意是虫子，现在泛指计算机硬件或者软件系统中的错误、缺陷等。**

**Debug:一般不将Debug称为除错，而是叫作调试，因为反复的调试过程才能去除BUG。**

**著名的加拿大计算机科学家Brian Wilson Kernighan说过一句有趣的名言：“调试的难度是编写代码的两倍，如果编写代码的时候已经黔驴技穷，那么你便没有足够的聪明才智去调试它了。**

### **1.2 为什么选择C/C++**

**本书主要介绍如何调试C/C++代码，如果掌握了本书的调试方法与技巧，其他语言的调试也能够驾轻就熟。**

### **1.3 什么是调试器**

**调试器（Debugger）是用来调试软件的工具，例如Windows系统的Visual Studio和Linux系统的gdb等。**

## **第2章 Visual C++调试基本功能**

**详细介绍了VisualC++的基本调试功能，包括断点管理、调试执行、监视变量、内存查看、堆栈、线程管理等，还介绍了一些断点的高级用法，比如条件断点、数据断点等。**

### **2.1 Visual C++ 简介**

**Visual C++（简称为Visual C++、MSVC、VC++或VC，方便起见，本书后续简称为VC）是微软公司的C++开发工具，具有集成开发环境，可提供编辑、编译、调试C/C++等编程语言的功能。**

### **2.2 断点管理**

**断点（breakpoint）是为了满足调试的需要而在程序中设置一些特殊标志，代码执行到包含特殊标志的位置时会暂停，我们可以查看或者修改程序运行的一些信息，比如内存信息、堆栈信息等，并且可以检查程序运行的结果，据此判断程序运行是否符合期望等。总而言之，断点就是程序中断（暂停运行）的地方。**

**TODO**

## **第3章 Linux系统gdb调试基本功能**

### **3.1 Linux C/C++编程基础知识**

#### **3.1.1 开发环境**

**在Linux系统中开发C/C++程序时，我们用到的工具一般是gcc和g++**

* **GCC（GNU Compiler Collection）即GNU编译工具集，有编译器、链接器、组装器等，主要用来编译C和C++语言，也可以编译Objective-C和Objective-C++程序。注意，这里的GCC是大写的，代表的是GNU编译工具集。**
* **gcc（GNU C Compiler）（注意，这里是小写的）代表的是GNU C语言编译器；g++代表的是GNU C++语言编译器。但是从本质上讲，gcc和g++并不是真正的编译器，它们也只是GCC里面的两个工具，在编译C/C++程序时，它们会调用真正的编译器对代码进行编译。可以简单地这样理解：gcc工作的时候会调用C编译器；g++工作的时候会调用C++编译器。二者的部分区别如下:**

  * **文件后缀名的处理方式不同：gcc会将后缀为.c的文件当作C程序，将后缀为.cpp的文件当作C++程序；g++会将后缀为.c和.cpp的都当成C++程序。要注意的是，gcc和g++都可以用来编译C和C++代码。**
  * **链接方式不同：gcc不会自动链接C++库（比如STL标准库），g++会自动链接C++库。**
* **预处理器宏不同：g++会自动添加一些预处理器宏，比如__cplusplus，但是gcc不会。**

**如果要开发纯C语言的程序，可以使用gcc；如果要开发C/C++程序，而且还要使用STL标准库。为了开发的便利性，建议使用g++。**

##### **1.CentOS上安装gcc和g++**

```
sudo yum install -y gcc gcc-c++
gcc -v //查看是否安装成功
```

##### **2.Ubuntu上安装gcc和g++**

```
sudo apt-get install gcc g++
g++ -v 
```

#### **3.1.2 开发第一个C/C++程序**

**本节将用GCC来开发C/C++代码.**

##### **1.使用C语言编写HelloWorld程序**

###### **编写源程序**

```
//文件名 helloworld.c
#include <stdio.h>

int main(int args , char **argv){
    printf("Hello,World!\n");
    return 0;
}
```

###### **gcc 编译链接**

```
$ gcc -o helloworld helloworld.c  
$ ./helloworld  
Hello,World!
```

###### **g++ 编译链接**

```
$ g++ -o helloworld helloword.c
clang: warning: treating 'c' input as 'c++' when in C++ mode, this behavior is deprecated [-Wdeprecated]
$ ./helloworld  
Hello,World!
```

##### **2.使用C++语言编写HelloWorld程序**

###### **编写源程序**

```
//文件名 helloworldplus.cpp
#include <iostream>
using namespace std;

int main(){
    cout << "Hello,World! C++" <<endl;
    return 0;
}
```

###### **gcc 编译链接**

```
$ gcc -o helloworldpluss helloworld.c  #会报错,由于gcc在链接C++代码时没有自动链接C++标准库，因此链接失败
$ gcc -o helloworldplus helloworldplus.cpp -lstdc++
$ ./helloworld  
Hello,World! C++
```

###### **g++ 编译链接**

```
$ g++ -o helloworldplus helloworldplus.cpp
$ ./helloworldplus  
Hello,World! C++
```

##### **3.使用Makefile**

**如果我们的程序比较复杂，实现的功能很多，包含的文件也很多，再使用g++来编译代码就会很麻烦。**

**Make（GNU Make）是Linux系统中的一款自动维护工具，它能够从程序的源代码中生成可执行文件。Make需要Makefile文件的配合，它从Makefile中获取构建程序的方法.**

**Make的功能很强大，它允许终端用户在不了解程序细节的情况下来构建和安装程序。如果程序中有文件发生改变，Make能够自动获取需要更新的文件，而且可以自动获取这些文件的顺序以及依赖关系等。因此，如果程序中的某个或者某些文件发生改变，Make并不需要去编译所有的源文件。**

**安装方法:**

```
yum install make # centos
apt-get install make #ubuntu
make -v
```

**Makefile文件中最重要的内容就是“规则”，即告诉make怎样去执行一系列命令，以便从源文件中构建目标文件。**

![image(1).png](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/03/15/image(1).png)

```bash
main: main.o student.o
	g++ -o chapter_3_make main.o student.o  
    #第一行目标为main，依赖main.o和student.o，要执行的命令是g++-o chapter_3 main.o student.o；
main.o: main.cpp
	g++ -c main.cpp
student.o: student.cpp stuendt.h
	g++ -c student.cpp
  
  
    # 执行make时，首先检测到main依赖main.o和student.o，
    # 然后再检查main.o和student.o，并依次执行它们的命令，
    # 最后一步执行g++ -o chatper_3 main.o student.o命令，
    # 生成chapter_3可执行文件。
```

**因为如果新增加了源代码文件，Makefile文件还需要修改。确实如此。作者在这里提供一个比较通用的Makefile示例，使用这个Makefile后，无论程序源文件怎样变换，几乎不用再进行修改:**[**https://github.com/SimpleSoft-2020/book_debug/blob/master/chapter_3.1/Makefile**](https://github.com/SimpleSoft-2020/book_debug/blob/master/chapter_3.1/Makefile)

**注意，依赖关系和命令可以书写为一行，命令之间要用分号隔开。一般采用写为多行的方式，以便查看。写为多行时，命令前面的空白不是空格，而是按下Tab键形成的。如果是空格，程序将会出错，不能正确进行编译，而且在使用make的时候会提示错误**

**使用上述的Makefile时,遇到了一个ERROR:clang: error: linker command failed with exit code 1 (use -v to see invocation)**

**一般来说时出现了两个main函数,make不知道该选择哪一个.注意之前的helloworld**

### **3.2 gdb简介**

**gdb（GNU debugger）是UNIX/Linux系统中强大的调试工具，它能够调试软件并分析软件的执行过程,可以支持C/C++、Go、Java、Objective-C等。**

#### **3.2.1 gdb的安装**

```
yum install -y gdb # centos
apt-get install -y gdb #ubuntu
```

#### **3.2.2 gdb常用功能**

![image(2).png](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/03/15/image(2).png)


### **3.3 调试执行**

**在编译程序时，无论是否使用本文介绍的通用Makefile，在使用gcc或者g++时一定要加上-g选项，以便能够正常调试程序。**

#### **3.3.1 启动调试**

**启动gdb调试的方式有好几种，最简单的一种就是执行命令：gdb程序名。在本示例中，要启动调试程序，则命令为：**`<span class="ne-text">gdb chapter_3_3</span>`

#### **3.3.2 启动调试并添加参数**

**假设需要两个参数，分别为admin和password，则需要在gdb命令窗口中输入以下命令：**`<span class="ne-text">set args admin password</span>`

#### **3.3.3 附加到进程**

**这个新的方式就是将已经运行的程序附加进来，将gdb附加到进程的命令如下：**

`<span class="ne-text">gdb attack <pid></span>`

---

**Mac中调试遇到的几个问题:推荐还是使用Liunx系统来操作,很多东西更方便.**

* **run之后停止:进入gdb，打好断点，运行，运行起来后，有如下日志，****之后不能继续执行，只能通过ctr+z让该程序在后台运行，之后使用kill命令杀掉该进程。然后再次进入，有可能就运行正常了。**

```
Starting program: /Users/franzkemmerich/work/42_school/test/a.out
[New Thread 0xd03 of process 1661]
```

**问题和 【**[**(gdb) 8.3.1 hangs after run command on mac Catalina**](https://github.com/Homebrew/homebrew-core/issues/49631#issue-558007139)**】一样。找到的一个解决方法：创建~/.gdbinit文件，并向该文件插入set startup-with-shell off语句。详细命令为**

```
touch ~/.gdbinit
echo "set startup-with-shell off" >> ~/.gdbinit
```

* **用gdb调试程序，运行时提示Unable to find Mach task port for process-id 83767: (os/kern) failure (0x5).****解决办法：加上sudo，即**`<span class="ne-text">sudo gdb executableFileName</span>`

---

### **3.4 断点管理**

#### **3.4.1 设置断点**

**gdb中的断点可以分为好个几种类，比如普通断点、条件断点、数据断点等，下面将详细介绍每一种断点的使用方式.**

##### **1.在源代码的某一行设置断点**

**在源代码某一行设置断点的语法如下,然后执行命令r启动程序。**

```shell
break 文件名:行号
```

**因为我们在第49行设置了第一个断点，所以代码运行到第49行时会暂停下来，这时就可以使用一些gdb命令来查看信息了。比如，输入list（缩写为l）来查看断点附近的代码，使用print（缩写为p）来查看变量的值，如图3-27所示。**

![image(4).png](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/03/15/image(4).png)

##### **2.为函数设置断点**

**为函数设置断点的语法如下：**

```
break 函数名
```

**如果有多个函数名相同，只是参数不同，为同名函数设置断点会怎样呢？gdb会为所有同名函数都设置断点，这一点其实很重要，尤其是******在C++的函数重载中，因为只看代码很难区分到底会调用哪一个函数。但是为函数设置断点后，就不用担心到底会执行哪一个函数。因为每个函数都会被设置断点，无论是哪一个函数被调用，都会命中。****

**如果多个类是继承关系，由于虚函数也是同名函数，所以当为函数设置断点时，无论是什么类型的函数，只要函数名满足条件，都会被设置断点。如果只想为特定的函数设置断点，则需要添加限定符，以便区分到底是为哪个函数设置断点。例如:**`<span class="ne-text">b test1:test_func</span>`**或者** `<span class="ne-text">b test_func(int)</span>`

##### **3.使用正则表达式设置函数断点**

**如果想为多个函数设置断点，但是这些函数名又各不相同,则可以使用正则表达式来为这些函数设置断点，比如使用*等。**

**对代码稍作改动，添加一个函数，名称为test_fun_x，这时代码包含多个以test_fun开头的函数名，就可以使用正则表达式来为满足规则的函数设置断点，语法如下**

```
rb 正则表达式
rbreak 正则表达式
rb test_func*
```

##### **4.通过偏移量设置断点**

**当前代码执行到某一行时，如果要为当前代码行的前面某一行或者后面某一行设置断点，就可以使用这个功能来达到快速设置断点的目的:**

```
b +偏移量
b -偏移量
```

##### **5.设置条件断点**

**所谓条件断点，就是当满足一定条件时断点才会命中。普通的断点只要代码执行到断点处就会命中并暂停下来，而条件断点必须要满足设置的条件，才能够命中并暂停。条件断点的语法如下：**

```
b 断点 条件
```

![image(5).png](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/03/15/image(5).png)

**可以使用info b命令查看断点的设置情况，如图3-34所示。**

##### **6.在指令地址上设置断点**

**如果调试程序没有符号信息，而我们又想在某些地方设置断点时，则可以使用在指令地址上设置断点的功能。**

```
b *指令地址
```

**去除-g选项，使得生成的可执行文件不包含调试符号信息。启动gdb并调试chapter_3.3，然后在测试函数cond_fun_test上设置一个断点。因为没有调试符号信息，所以第一步先获得cond_fun_test函数的地址，执行下述命令：**`<span class="ne-text">p cond_fun_test </span>`**该命令会获得函数cond_fun_test的函数地址，这里是0x400a0b。然后为地址0x400a0b设置断点，命令如下：**`<span class="ne-text">b *0x400a0b</span>`**在gdb中输入r，运行程序，就会在函数cond_fun_test中暂停.**

##### **7.设置临时断点**

**顾名思义，临时断点是指这个断点是临时的，只命中一次，然后会被自动删除，后续即使代码被多次调用也不会再次命中。**

```
tbreak 断点
tb 断点
```

#### **3.4.2 启用/禁用断点**

**如果一个断点被禁用，则该断点不会被命中，但是它仍然会在断点列表中显示。我们仍然可以通过info b来查看被禁用的断点，也可以通过启用断点命令来重新启用被禁用的断点。**

**禁用断点的语法如下：**`<span class="ne-text">disable 断点编号</span>`

**启用断点的语法如下：**`<span class="ne-text">enable 断点编号</span>`

**也可以对一个范围内的断点执行启用或禁用操作，比如禁用编号为4~10的断点，**

**则可以使用下述命令：**`<span class="ne-text">disable 4-10</span>`

#### **3.4.3　启用断点一次**

**这是启用断点的一种变化用法，在启用断点时，可以只启用一次，命中一次后会自动禁用，不会再次命中。它与临时断点相似，临时断点只会命中一次，命中一次之后就会自动删除。启用断点一次的不同之处在于断点启用后，虽然只会命中一次，但是不会被删除，而是被禁用.**

```
enable once 断点编号
```

#### **3.4.4　启用断点并删除**

**这同样是启用断点的一种变化用法，即如果断点被启用，当下次命中该断点后，会自动删除。该功能与临时断点相似，相当于把一个被禁用的断点转换为临时断点。**

```
enable delete 断点编号
```

#### **3.4.5　启用断点并命中N次**

**这也是启用断点的一种变化用法，即启用断点后可以命中N次，但是命中N次后，该断点就会被自动禁用，不会再次命中。**

```
enable count 数量 断点编号
```

#### **3.4.6　忽略断点前N次命中**

**这个功能很有用，也很有趣，与条件断点类似，即在设置断点时可以指定接下来的N次命中都忽略，直到第N+1次命中时运行才暂停。**

```
ignore 断点编号 次数
```

### **3.4.7　查看断点**

**查看断点可以通过下列命令实现：**

```
info breakpoints <断点编号>
info break <断点编号>
info b <断点编号>
i b <断点编号>
```

### **3.4.8　删除断点**

**1.删除所有断点：delete**

```
delete
delete <id>
delete 5 6
delete 5-7
delete 5-7 10-12
```

**2.删除指定函数的断点：clear函数名**

```
clear test_fun
```

**3.删除指定行号的断点：clear行号**

****删除断点命令clear和delete是有区别的。delete命令是全局的，不受栈帧的影响；clear命令受到当前栈帧的制约，删除的是将要执行的下一处指令的断点。delete命令可以删除所有断点，包括观察点和捕获点等；clear命令不能删除观察点和捕获点。****

### **3.5 程序执行**

#### **3.5.1 启动程序**

**启动程序的命令为** `<span class="ne-text">run</span>`**或者** `<span class="ne-text">r</span>`**，一般用于调试一个程序。r命令只在使用gdb启动被调试的程序时执行一次.**

**然后进入gdb的调试窗口，这时程序被暂停，可以执行设置启动参数、设置断点等操作。然后在gdb中输入run启动程序，直到遇到第一个命中的断点为止，程序才会中断.**

#### **3.5.2 继续运行**

**继续运行可以使用命令** `<span class="ne-text">continue</span>`**或者** `<span class="ne-text">c</span>`**。当程序处于中断状态时，比如已经命中断点，则可以执行continue命令恢复或者继续运行程序，直到遇到下一个断点为止**

#### **3.5.3 继续运行并跳过当前断点N次**

**在使用continue命令时，还可以设置跳过当前断点的命中次数。**

```
continue 次数
```

#### **3.5.4　继续运行直到当前函数执行完成**

**如果在一个比较长的函数中设置了断点，当命中函数断点时，我们可能不想逐步执行代码，而是跳过部分代码的调试过程，直接回到调用函数的位置，此时可以使用这个功能。语法如下：**

```
finish
```

#### **3.5.5 单步执行**

**gdb单步执行的命令如下:**

```
step
```

**或者**

```
s
```

**当进入到断点所在代码时，可以输入step或者s命令执行该行代码。如果该行代码有函数调用，会直接进入该函数内部继续执行；如果没有函数调用，则直接执行下一行。**

#### **3.5.6 逐过程执行**

**逐过程执行与单步执行类似，执行一次就会进入下一行。但是，如果当前代码行有函数调用，单步执行会进入到函数中，逐过程执行则不会进入到函数中。无论有多少个函数调用，逐过程执行都会进入到下一行代码。**

**命令如下:**

```
next
```

**或者**

```
n
```

### **3.6 查看当前函数参数**

**当程序在函数中暂停后，即可查看函数的参数。语法如下：**

```
info agrs
```

**或者**

```
args
```

### **3.7　查看/修改变量的值**

**在程序命中断点时，可以查看变量的值。这个变量可以是全局变量，也可以是局部变量，而且当前上下文能够访问的变量都可以查看。**

```
print 变量名
p 变量名
```

**如果要修改查看到的变量值，可以使用下述命令：**

```
print 变量名=值
```

**即如果要改变x变量的值，将它修改为20，可以使用命令px=20。对于结构体或者类对象，也可以使用这种方式修改成员的值**

#### **3.7.1 使用gdb内嵌函数 (****TODO:许多内嵌函数没有返回值会报错无法执行,需要自己输入返回值****)**

**在使用print或者p命令时，可以直接使用gdb内嵌的一些函数（比如C函数），比如sizeof、strcmp等，也可以使用一些常见的表达式。当使用内嵌函数时，通常不是查看某个变量的值，而是进行一些计算或者比较等操作。这样，就可以实时地查看一些信息。比如，想了解long在Linux gcc下占用几个字节长度、某个结构体所占用的空间大小等，都可以使用sizeof来计算。比如可以直接使用p sizeof(long)、p sizeof(NODE)等。**

**我们甚至可以在gdb中直接进行开发。这说起来有些夸张，但是确实可以调用很多C函数来进行各种操作。比如我们可以在gdb中直接调用文件操作的函数，打开一个文件并向其中写入一些内容，最后关闭文件，**

![image(6).png](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/2022/03/15/image(6).png)

#### **3.7.2 查看结构体/类的值**

**要查看结构体各个成员的值比较麻烦，如果这个结构体有3个数据成员，所以使用了3次p命令。**

```
(gdb) p new_node
$4 = (NODE *) 0x6030a0
(gdb) p new_node->ID
$5 = 0
(gdb) p new_node->Name
$6 = "aaa", '\000' <repeats 36 times>
(gdb) p new_node->age
$7 = 20
```

**查看new_node结构体更加方便的方式是直接查看这个结构体的对象值，而不是new_node指针本身。也就是说，在查看new_node指针指向的内容的值时，使用p*new_node可以显示整个结构体的成员信息**

```
p *new_node
$8 = {ID = 0, Name = "aaa", '\000' <repeats 36 times>, age = 20, prev = 0x603050, next = 0x0}
  
##也可以进行打印美化
set print null-stop
set print pretty
p *node_head->prev
$13 = {
  ID = 0,
  Name = "aaa",
  age = 20,
  prev = 0x603050,
  next = 0x0
}
```

#### **3.7.3 查看数组**

**使用print或者p命令也可以查看数组的信息。**

```
(gdb) set print array on #美化
(gdb) print strarr
$5 =   {0x40151a "this",
  0x40151f "is",
  0x401522 "a",
  0x401524 "test",
  0x401529 "string"}
(gdb) print iarr
$6 =   {0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9}
```

### **3.8 自动显示变量的值**

**3.7节中介绍了使用print或者p命令来显示变量的值，但是遇到了一个问题，即如果想要查看某个变量的值，需要不停地使用print命令。**

**gdb还有另外一个display命令，每次程序暂停都可以自动显示变量值。**

```
display 变量名
display {变量名1,变量名2,变量名3}
```

### **3.9　显示源代码**

**gdb可以在调试的时候显示源代码信息。查看源代码的命令是list或者l。当程序命中断点或者暂停后可以使用list命令查看相关的源代码。**

**因为加上编译选项-g后，生成的可执行文件中包含调试信息，并且保存了对应的源文件信息（只是保存了源文件名等信息），所以在查看源代码时，要确保对应的源文件存在，否则无法查看。**

**在程序中断时，可以使用l命令来查看源代码信息。默认情况下，使用l命令可以显示10行源代码—当前代码行的前面5行和后面5行，**

**换行l命令时，每次默认显示10行代码，如果觉得每次显示的代码太少，可以通过set listsize命令来改变每次显示代码的行数。比如，希望每次能够显示20行代码，可执行下述命令：**

```
set listsize 20
```

**还可以使用list命令查看指定函数的代码，语法为“list函数名”。比如，我们要查看add_member函数的源代码，可以使用下述命令：**

```
list add_member
```

**如果想要查看指定文件的指定行代码，则可以使用下述命令**

```
list 文件名:行号
```

### **3.10 查看内存**

**gdb也可以查看内存，命令是** `<span class="ne-text">x</span>`**。x命令有很多选项，包括显示的方式（比如是以十六进制、十进制显示，还是以字符串方式显示等）。如果能够很好地使用x命令，基本上可以达到或者超越VC的内存查看效果。**

**使用gdb启动调试，执行b test_memory命令为test_memory函数设置一个断点，或者直接在124行设置一个断点。断点命中时，使用x命令查看各个变量的内存信息。x命令的语法如下：**

```
x /选项 地址
```

**命令x并不局限于查看变量的内存信息，无论是函数地址、变量地址，还是其他地址，只要地址合法而且可以访问，都可以使用x命令来查看。**

### **3.11　查看寄存器**

**寄存器是CPU内部用来存放数据的一些区域，是CPU内部的高速存储单元，用来临时存放一些参与计算的数据，比如函数参数、程序指针等。CPU可以直接操作寄存器中的值，且速度要比访问内存快得多。寄存器主要分为通用寄存器、指针寄存器、段寄存器和标志寄存器等。**

* **通用寄存器（General Purpose Register）：尽管通用寄存器是通用的，可以存储任意数据，但大多时候主要用来存储操作数和运算结果等信息。比如，32位通用寄存器对应的为EAX、EBX、ECX、EDX、ESP、EBP、ESI、EDI；64位通用寄存器对应的为RAX、RBX、RCX、RDX、RSP、RBP、RSI、RDI等。其中，EBP（RBP）是基指针寄存器，可以直接访问栈中的数据；ESP（RSP）是栈指针寄存器；只能访问栈顶的数据。**
* **指针寄存器（Pointer Register）：又称为指令寄存器，用来存放指令指针。32位为EIP，64位为RIP**
* **段寄存器（Segment Register）：用来存储段数据的段值，比如存储数据段的段值、代码段的段值等。段寄存器主要有CS（代码段）、DS（数据段）、ES（附加段）、FS（通用段）、GS（通用段）、SS（栈段）**
* **标志寄存器（RFLAGS Register）：显示程序状态的寄存器，主要有CF（Carry Flag，进位或者错位）、AF（AdjustFlag，辅助进位）、ZF（Zero Flag，零标志）等。**

**在gdb中，指令寄存器$rip指向当前执行的代码位置，栈指针寄存器$rsp指向当前栈顶，通用寄存器会存储一些变量的值、函数参数以及函数返回值等**

**一般情况下，函数的参数会存放在寄存器中，所以我们用查看寄存器的方式来查看传递的参数是什么。查看寄存器的命令如下：**

```
info registers
```

**而下述命令则显示所有寄存器的值，包括浮点寄存器等。**

```
info all-registers
```

### **3.12 查看调用栈**

**当程序进行函数调用时，这些调用信息（比如在哪里调用等）称为栈帧。每一个栈帧的内容还包括调用函数的参数、局部变量等。所有栈帧组成的信息称为调用栈（或者调用堆栈）。**

**当程序刚开始运行时，只有一个栈帧，即主函数main。每调用一个函数，就产生一个新的栈帧；当函数调用结束时（即从函数返回后），该函数的调用随之结束，该栈帧也结束。如果该函数是一个递归函数，则调用该函数会产生多个栈帧。**

#### **3.12.1 查看栈回溯信息**

**查看栈回溯信息的命令是** `<span class="ne-text">backtrace</span>`**。执行该栈回溯命令后，会显示程序执行到什么位置、包含哪些帧等信息。每一帧都有一个编号，从0开始。0表示当前正在执行的函数，1表示调用当前函数的函数，以此类推。栈回溯是倒序排列的.命令** `<span class="ne-text">backtrace</span>`**可以简写为** `<span class="ne-text">bt</span>`**。**

**也可以执行命令来查看指定数量的栈帧：**

```
bt 栈帧数量
```

#### **3.12.2 切换栈帧**

**可以通过“**`<span class="ne-text">frame 栈帧号</span>`**”或者** `<span class="ne-text">f 栈帧号</span>`**或者** `<span class="ne-text">f 帧地址</span>`**的方式来切换栈帧。为什么要切换栈帧呢？因为每一个栈帧所对应的程序的运行上下文都不同，比如栈帧1的局部变量和栈帧2的局部变量都不相同，只有切换到某个具体的栈帧之后才能查看该栈帧对应的局部**

#### **3.12.3 查看帧信息**

**可以使用info frame命令（包括前面介绍的info locals和info args命令）来查看帧的详细信息，还可以使用info frame命令来查看具体的某一帧的详细信息。比如要查看编号为1的帧的详细信息，可以直接使用info frame 1（可以简写为i f 1）命令，而不用先进行帧的切换操作。**

### **3.13 线程管理**

**对于现代程序来讲，大多情况下是多个线程在同时工作，从而充分利用系统资源。**

**这是因为我们在程序中用到了线程函数，但是链接时不包含线程库，所以还需要在Makefile中添加线程库（pthread）**

#### **3.13.1 查看所有线程信息**

**使用命令** `<span class="ne-text">info threads</span>`**查看当前进程所有的线程信息**

**当前进程共有11个线程，编号为1~11，其中1号线程前面有一个*号，表示1号线程是当前线程。每个线程信息还包含执行位置，即处于哪个文件的哪一行代码处。**

#### **3.13.2 切换线程**

**当前线程很重要，因为很多命令都是针对当前线程有效。比如，查看栈回溯的bt命令、查看栈帧的f命令等都是针对当前线程。如果想要查看某个线程堆栈的相关信息，必须要先切换到该线程,切换线程的命令如下：**

```
thread 线程ID
```

**这个时候就可以使用命令i locals来查看当前帧的局部变量信息**

#### **3.13.3 为线程设置断点**

**可以通过断点命令break或者b来为特定线程设置断点，命令语法如下：**

```
break 断点 thread 线程ID
```

#### **3.13.4　为线程执行命令**

**在查看线程信息时，还可以为一个线程或者多个线程执行命令。也就是说可以为指定线程执行命令，比如为2号线程执行info args命令。为线程执行命令的语法如下：**

```
thread apply 线程号 命令
```

**由于每个线程的栈帧比较多，屏幕上无法全部显示，所以图3-97中只截取了前面一部分线程信息。用于查看所有线程栈回溯信息的命令** `<span class="ne-text">thread apply all bt</span>`**非常有用，尤其是在大型程序的调试过程中，比如死锁的调试**
