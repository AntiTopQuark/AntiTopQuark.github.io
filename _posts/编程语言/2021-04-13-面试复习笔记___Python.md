---
layout: post_draft
cid: 90
title: 面试复习笔记 : Python
slug: @90
date: 2021/04/13 17:54:00
updated: 2021/04/15 11:15:41
status: publish
author: AntiTopQuark
categories: 
  - 编程语言
tags: 
  - value
  - type
  - 类型
  - func
  - 节点
  - 函数
  - 缓冲
  - 接口
  - 变量
  - 实例
  - 容器
  - 程序
  - int
  - 方法
  - 编译
  - 切片
  - 语句
  - 分配
  - 语言
  - 内存
  - 系统
  - 一致性
  - 事务
  - 用户
  - 进程
  - python
  - print
  - foo
  - 对象
  - Python
  - 文件
  - 任务
  - map
  - 数据
  - 操作
  - 模型
  - class
  - 过程
  - 原理
  - 索引
  - with
  - 日志
  - 参数
  - 组织
  - 创建
  - o
  - 语法
  - 区别
  - 字符
  - str
  - 标记
  - key
  - 测试
  - 环境
  - 内核
  - 搜索
  - 深度
  - return
  - g
  - 软件
  - 程序员
  - 处理
  - 大写
  - 文档
  - reduce
  - tuple
  - 知乎
  - 问题
  - 编程
  - local
  - 集合
  - count
  - 算法
  - state
  - 动作
customSummary: 
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---


[TOC]
# 1 Python的函数参数传递

看两个例子：
```python
a = 1
def fun(a):
    a = 2
fun(a)
print(a) # 1
```

```python
a = []
def fun(a):
    a.append(1)
fun(a)
print a  # [1]
```
python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。
所有的变量都可以理解是内存中一个对象的“引用”。通过`id`来看引用`a`的内存地址可以更容易理解：

```python
a = 1
def fun(a):
    print ("func_in",id(a) )  # func_in 41322472
    a = 2
    print ("re-point",id(a), id(2))   # re-point 41322448 41322448
print ("func_out",id(a), id(1))  # func_out 41322472 41322472
fun(a)
print(a)  # 1
```

可以看到，在执行完`a = 2`之后，`a`引用中保存的值，即内存地址发生变化，由原来`1`对象的所在的地址变成了`2`这个实体对象的内存地址。
而第2个例子`a`引用保存的内存值就不会发生变化：

```python
a = []
def fun(a):
    print ("func_in",id(a))  # func_in 53629256
    a.append(1)
print ("func_out",id(a))     # func_out 53629256
fun(a)
print (a)  # [1]
```
可更改(mutable)与不可更改(immutable)对象:
- 不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向10，而 5 被丢弃，不是改变a的值，相当于新生成了a。
- 可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。

在 python 中，string, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。
python 函数的参数传递：
- 不可变类型：类似 c++ 的值传递，如 数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。
- 可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响

# 2 Python中的元类(metaclass)
## type
OOP中有2个基本概念：类和对象：
1. 类是描述如何创建一个对象的代码段，用来描述具有相同的属性和方法的对象的集合，它定义了该集合中每个对象所共有的属性和方法
2. 对象是类的实例（Instance）。

在Python中，类是对象，只要你使用关键字 class，Python执行它， 并创建一个对象。此对象(类) 本身是能够创建(实例) ， 这就是为什么它是一个类的对象 . [1] 因此：可以将它赋给一个变量；可以复制它；可以向它添加属性；可以将它作为函数的参数
参考：[https://www.cnblogs.com/tkqasn/p/6524879.html][1]
我们可以动态的创建类,使用type函数。

> type(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)

```python
1、构建Foo类
#构建目标代码
class Foo(object):
    bar = True
#使用type构建
Foo = type('Foo', (), {'bar':True})

2.继承Foo类
#构建目标代码：
class FooChild(Foo):
    pass
#使用type构建
FooChild = type('FooChild', (Foo,),{})

print FooChild
#输出：<class '__main__.FooChild'>
print FooChild.bar   # bar属性是由Foo继承而来
#输出：True

3.为Foochild类增加方法
def echo_bar(self):
    print self.bar

FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})
hasattr(Foo, 'echo_bar')
#输出：False
hasattr(FooChild, 'echo_bar')
#输出：True
my_foo = FooChild()
my_foo.echo_bar()
#输出：True
```
## 什么是元类
通过Python中的类也是对象。元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解为：
```python
MyClass = MetaClass()    #元类创建类
MyObject = MyClass()     #类创建实例
实际上MyClass就是通过type()来创创建出MyClass类，它是type()类的一个实例；同时MyClass本身也是类，也可以创建出自己的实例，这里就是MyObject
```
函数type实际上是一个元类。type就是Python在背后用来创建所有类的元类。现在你想知道那为什么type会全部采用小写形式而不是Type呢？好吧，我猜这是为了和str保持一致性，str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。你可以通过检查__class__属性来看到这一点。Python中所有的东西，注意，我是指所有的东西——都是对象。这包括整数、字符串、函数以及类。它们全部都是对象，而且它们都是从一个类创建而来。
因此，元类就是创建类这种对象的东西,type就是Python的内建元类，当然了，你也可以创建自己的元类。

### metaclass 属性
你可以在写一个类的时候为其添加__metaclass__属性,定义了__metaclass__就定义了这个类的元类。
```python
class Foo(metaclass=something):   #py3
    __metaclass__ = something…
```
例如：当我们写如下代码时 :
```python
class Foo(Bar):
    pass
```
在该类并定义的时候，它还没有在内存中生成，直到它被调用。Python做了如下的操作：
1）Foo中有__metaclass__这个属性吗？如果是，Python会在内存中通过__metaclass__创建一个名字为Foo的类对象。
2）如果Python没有找到__metaclass__属性，它会继续在父类中寻找__metaclass__属性，并尝试做和前面同样的操作。
3）如果Python在任何父类中都找不到__metaclass__，它就会在模块层次中去寻找__metaclass__，并尝试做同样的操作。
4）如果还是找不到__metaclass__,Python就会用内置的type来创建这个类对象。

现在的问题就是，你可以在__metaclass__中放置些什么代码呢？
答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化type的东西都可以。比如使用函数当做元类，或者类。
```python
# 元类会自动将你通常传给‘type’的参数作为自己的参数传入
def upper_attr(future_class_name, future_class_parents, future_class_attr):
    '''返回一个类对象，将属性都转为大写形式'''
    #选择所有不以'__'开头的属性
    attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
    # 将它们转为大写形式
    uppercase_attr = dict((name.upper(), value) for name, value in attrs)
    #通过'type'来做类对象的创建
    return type(future_class_name, future_class_parents, uppercase_attr)#返回一个类

class Foo(metaclass = upper_attr):
    bar = 'bip'
print hasattr(Foo, 'bar')
# 输出: False
print hasattr(Foo, 'BAR')
# 输出:True
 
f = Foo()
print f.BAR
# 输出:'bip'
```

###2、使用class来当做元类

请记住，'type'实际上是一个类，就像'str'和'int'一样。所以，你可以从type继承
`__new__ 是在__init__之前被调用的特殊方法，__new__是用来创建对象并返回之的方法，__new_()是一个类方法,而__init__只是用来将传入的参数初始化给对象，它是在对象创建之后执行的方法。你很少用到__new__，除非你希望能够控制对象的创建。这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__`
`如果你希望的话，你也可以在__init__中做些事情。还有一些高级的用法会涉及到改写__call__特殊方法，但是我们这里不用，下面我们可以单独的讨论这个使用`
```python
class UpperAttrMetaClass(type):
    def __new__(upperattr_metaclass, future_class_name, future_class_parents, future_class_attr):
        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)
        return type(future_class_name, future_class_parents, uppercase_attr)#返回一个对象，但同时这个对象是一个类
```

# 3 @staticmethod和@classmethod

Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:
```python
def foo(x):
    print "executing foo(%s)"%(x)

class A(object):
    def foo(self,x):
        print "executing foo(%s,%s)"%(self,x)

    @classmethod
    def class_foo(cls,x):
        print "executing class_foo(%s,%s)"%(cls,x)

    @staticmethod
    def static_foo(x):
        print "executing static_foo(%s)"%x

a=A()
```
这里先理解下函数参数里面的self和cls.
这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用`foo(x)`,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.
对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是`foo(self, x)`,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的`a.foo(x)`(其实是`foo(a, x)`).
类方法一样,只不过它传递的是类而不是实例,`A.class_foo(x)`.
注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.
对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用`a.static_foo(x)`或者`A.static_foo(x)`来调用.

| \\      | 实例方法     | 类方法            | 静态方法            |
| :------ | :------- | :------------- | :-------------- |
| a = A() | a.foo(x) | a.class_foo(x) | a.static_foo(x) |
| A       | 不可用      | A.class_foo(x) | A.static_foo(x) |

# 4 类变量和实例变量

**类变量：**

> ​	是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。

**实例变量：**

> 实例化之后，每个实例单独拥有的变量。

```python
class Test(object):  
    num_of_instance = 0  
    def __init__(self, name):  
        self.name = name  
        Test.num_of_instance += 1  
  
if __name__ == '__main__':  
    print Test.num_of_instance   # 0
    t1 = Test('jack')  
    print Test.num_of_instance   # 1
    t2 = Test('lucy')  
    print t1.name , t1.num_of_instance  # jack 2
    print t2.name , t2.num_of_instance  # lucy 2
```

> 补充的例子

```python
class Person:
    name="aaa"

p1=Person()
p2=Person()
p1.name="bbb"
print p1.name  # bbb
print p2.name  # aaa
print Person.name  # aaa
```

这里`p1.name="bbb"`是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,`p1.name`一开始是指向的类变量`name="aaa"`,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.

可以看看下面的例子:

```python
class Person:
    name=[]

p1=Person()
p2=Person()
p1.name.append(1)
print p1.name  # [1]
print p2.name  # [1]
print Person.name  # [1]
```
# 5 Python自省

这个也是python彪悍的特性.

自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().

```python
a = [1,2,3]
b = {'a':1,'b':2,'c':3}
c = True
print type(a),type(b),type(c) # <type 'list'> <type 'dict'> <type 'bool'>
print isinstance(a,list)  # True

``` 
# 6 字典推导式

可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:

```python

d = {key: value for (key, value) in iterable}

```


# 7 Python中单下划线和双下划线

```python
>>> class MyClass():
...     def __init__(self):
...             self.__superprivate = "Hello"
...             self._semiprivate = ", world!"
...
>>> mc = MyClass()
>>> print mc.__superprivate
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: myClass instance has no attribute '__superprivate'
>>> print mc._semiprivate
, world!
>>> print mc.__dict__
{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}
```

`__foo__`:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如`__init__()`,`__del__()`,`__call__()`这些特殊方法

`_foo`:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；

`__foo`:这个有真正的意义:解析器用`_classname__foo`来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问.

# 8 字符串格式化:%和.format

.format在许多方面看起来更便利.对于`%`最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:

```
"hi there %s" % name
```

但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:

```
"hi there %s" % (name,)   # 提供一个单元素的数组而不是一个参数
```

但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.
```python
>>>"{} {}".format("hello", "world")    # 不设置指定位置，按默认顺序
'hello world'
 
>>> "{0} {1}".format("hello", "world")  # 设置指定位置
'hello world'
 
>>> "{1} {0} {1}".format("hello", "world")  # 设置指定位置
'world hello world'

print("网站名：{name}, 地址 {url}".format(name="菜鸟教程", url="www.runoob.com"))
 
# 通过字典设置参数
site = {"name": "菜鸟教程", "url": "www.runoob.com"}
print("网站名：{name}, 地址 {url}".format(**site))
 
# 通过列表索引设置参数
my_list = ['菜鸟教程', 'www.runoob.com']
print("网站名：{0[0]}, 地址 {0[1]}".format(my_list))  # "0" 是必须的
```
# 9 迭代器和生成器

这是中文版: http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html

这里有个关于生成器的创建问题面试官有考：
问：  将列表生成式中[]改成() 之后数据结构是否改变？ 
答案：是，从列表变为生成器

```python
>>> L = [x*x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x*x for x in range(10))
>>> g
<generator object <genexpr> at 0x0000028F8B774200>
```
通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—>generator

# 10 `*args` and `**kwargs`

用`*args`和`**kwargs`只是为了方便并没有强制使用它们.

当你不确定你的函数里将要传递多少参数时你可以用`*args`.例如,它可以传递任意数量的参数:

```python
>>> def print_everything(*args):
        for count, thing in enumerate(args):
...         print '{0}. {1}'.format(count, thing)
...
>>> print_everything('apple', 'banana', 'cabbage')
0. apple
1. banana
2. cabbage
```

相似的,`**kwargs`允许你使用没有事先定义的参数名:

```python
>>> def table_things(**kwargs):
...     for name, value in kwargs.items():
...         print '{0} = {1}'.format(name, value)
...
>>> table_things(apple = 'fruit', cabbage = 'vegetable')
cabbage = vegetable
apple = fruit
```

你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给`*args`和`**kwargs`.命名参数在列表的最前端.例如:

```
def table_things(titlestring, **kwargs)
```

`*args`和`**kwargs`可以同时在函数的定义中,但是`*args`必须在`**kwargs`前面.

当调用函数时你也可以用`*`和`**`语法.例如:

```python
>>> def print_three_things(a, b, c):
...     print 'a = {0}, b = {1}, c = {2}'.format(a,b,c)
...
>>> mylist = ['aardvark', 'baboon', 'cat']
>>> print_three_things(*mylist)

a = aardvark, b = baboon, c = cat
```

就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.

# 11 面向切面编程AOP和装饰器

**AOP**
简言之、这种在运行时，编译时，类和方法加载时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是面向切面的编程。

我们管切入到指定类指定方法的代码片段称为切面，而切入到哪些类、哪些方法则叫切入点。有了AOP，我们就可以把几个类共有的代码，抽取到一个切片中，等到需要时再切入对象中去，从而改变其原有的行为。

优点是：这样的做法，对原有代码毫无入侵性
**装饰器**
装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。

概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。
作者：张晓天a
链接：https://www.jianshu.com/p/4c588eec1be1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

装饰器用法 ： [https://www.runoob.com/w3cnote/python-func-decorators.html][2]

```python
def a_new_decorator(a_func):
    def wrapTheFunction():
        print("a_func() 之前")
        a_func()
        print("a_func() 之后")

    return wrapTheFunction


def a_func():
    print("a_func()")


a_func()
# outputs: a_func()
a_function_requiring_decoration = a_new_decorator(a_func)
a_function_requiring_decoration()
# outputs：
# a_func() 之前
# a_func()
# a_func() 之后
```

这正是 python 中装饰器做的事情！它们封装一个函数，并且用这样或者那样的方式来修改它的行为。现在你也许疑惑，我们在代码里并没有使用 @ 符号？那只是一个简短的方式来生成一个被装饰的函数。这里是我们如何使用 @ 来运行之前的代码：

```python
@a_new_decorator
def b_func():
    """Hey you! Decorate me!"""
    print("b_func()")


b_func()
#outputs:
# a_func() 之前
# b_func()
# a_func() 之后

```

希望你现在对 Python 装饰器的工作原理有一个基本的理解。如果我们运行如下代码会存在一个问题：
```python
print(a_function_requiring_decoration.__name__)
# Output: wrapTheFunction
```
这并不是我们想要的！Ouput输出应该是"a_function_requiring_decoration"。这里的函数被warpTheFunction替代了。它重写了我们函数的名字和注释文档(docstring)。幸运的是Python提供给我们一个简单的函数来解决这个问题，那就是functools.wraps。我们修改上一个例子来使用functools.wraps：
```python
from functools import wraps
 
def a_new_decorator(a_func):
    @wraps(a_func)
    def wrapTheFunction():
        print("I am doing some boring work before executing a_func()")
        a_func()
        print("I am doing some boring work after executing a_func()")
    return wrapTheFunction
 
@a_new_decorator
def a_function_requiring_decoration():
    """Hey yo! Decorate me!"""
    print("I am the function which needs some decoration to "
          "remove my foul smell")
 
print(a_function_requiring_decoration.__name__)
# Output: a_function_requiring_decoration
``` 
现在好多了。我们接下来学习装饰器的一些常用场景。

蓝本规范:
```python
from functools import wraps
def decorator_name(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        if not can_run:
            return "Function will not run"
        return f(*args, **kwargs)
    return decorated
 
@decorator_name
def func():
    return("Function is running")
 
can_run = True
print(func())
# Output: Function is running
 
can_run = False
print(func())
# Output: Function will not run
```

 
# 12 鸭子类型

“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”

我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。

比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。

又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.

鸭子类型在动态语言中经常使用，非常灵活，使得python不像java那样专门去弄一大堆的设计模式。

# 13 Python中重载

引自知乎:http://www.zhihu.com/question/20053359

函数重载主要是为了解决两个问题。

1. 可变参数类型。
2. 可变参数个数。

另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。

好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。

那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。

好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。

# 14 新式类和旧式类


这篇文章很好的介绍了新式类的特性: http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html
新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类继承是根据C3算法,旧式类是深度优先),<Python核心编程>里讲的也很多.

MRO(Method Resolution Order， 方法解析顺序)
对于下图的多继承关系：
![03290-l0z221xvgan.png](http://www.sukidesu.top/usr/uploads/2020/04/1566766245.png)
b = A()，当调用b.a的时候会发生什么事呢？
在经典对象模型中，方法和属性的查找链是按照从左到右，深度优先的方式进行查找。所以当A的实例b
要使用属性a时，它的查找顺序为:A->B->D->C->A，这样做就会忽略类C的定义a，而先找到的基类D的
属性a，这是一个bug，这个问题在新式类中得到修复，新的对象模型采用的是从左到右，广度优先的方式
进行查找，所以查找顺序为A->B->C->D，可以正确的返回类C的属性a。
经典类：
![41294-6vmv6awe71i.png](http://www.sukidesu.top/usr/uploads/2020/04/3335193817.png)
新式类：
  ![53021-nqd7tga2npg.png](http://www.sukidesu.top/usr/uploads/2020/04/1104832316.png)
这个顺序的实现是通过新式类中特殊的只读属性__mro__，类型是一个元组，保存着解析顺序信息。只能通过
类来使用，不能通过实例调用。
![68030-q69eivty1xk.png](http://www.sukidesu.top/usr/uploads/2020/04/2634158077.png)
顺序还和继承时，括号中写的父类顺序有关：
![04360-fgohj75u8vc.png](http://www.sukidesu.top/usr/uploads/2020/04/3935399397.png)

**按照经典类的查找顺序`从左到右深度优先`的规则，在访问`d.foo1()`的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过**


# 15 `__new__`和`__init__`的区别

这个`__new__`确实很少见到,先做了解吧.

1. `__new__`是一个静态方法,而`__init__`是一个实例方法.
2. `__new__`方法会返回一个创建的实例,而`__init__`什么都不返回.
3. 只有在`__new__`返回一个cls的实例时后面的`__init__`才能被调用.
4. 当创建一个新实例时调用`__new__`,初始化一个实例时用`__init__`.

ps: `__metaclass__`是创建类时起作用.所以我们可以分别使用`__metaclass__`,`__new__`和`__init__`来分别在类创建,实例创建和实例初始化的时候做一些小手脚.

# 16 单例模式

> ​	单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。
>
> `__new__()`在`__init__()`之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例
**这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.**

### 1 使用`__new__`方法

```python
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, '_instance'):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1
```

### 2 共享属性

创建实例时把所有实例的`__dict__`指向同一个字典,这样它们具有相同的属性和方法.

```python

class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1
```

### 3 装饰器版本

```python
def singleton(cls):
    instances = {}
    def getinstance(*args, **kw):
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance

@singleton
class MyClass:
  ...
```

### 4 import方法

作为python的模块是天然的单例模式

```python
# mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass

my_singleton = My_Singleton()

# to use
from mysingleton import my_singleton

my_singleton.foo()

```
**[单例模式伯乐在线详细解释](http://python.jobbole.com/87294/)**

# 17 Python中的作用域

Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。

当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：

本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）

python中的作用域分4种情况：
L：local，局部作用域，即函数中定义的变量；
E：enclosing，嵌套的父级函数的局部作用域，即包含此函数的上级函数的局部作用域，但不是全局的（闭包常见）；
G：globa，全局变量，就是模块级别定义的变量；
B：built-in，系统固定模块里面的变量，比如int, bytearray等。

local 和 enclosing 是相对的，enclosing 变量相对上层来说也是 local 

# 18 GIL线程全局锁

线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是对于任何Python程序，不管有多少的处理器，任何时候都总是只有一个线程在执行。**对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。**

见[Python 最难的问题](http://www.oschina.net/translate/pythons-hardest-problem)
[Cpu核心数和线程进程之间的关系](https://www.cnblogs.com/kimsimple/p/7787018.html)
[Python多进程编程](https://www.cnblogs.com/kaituorensheng/p/4445418.html)

解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).


# 19 协程

简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.

Python里最常见的yield就是协程的思想!可以查看第九个问题.

[Python协程](https://www.cnblogs.com/zhangxinqi/p/8337207.html)

# 20 闭包

闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。
当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:

1. 必须有一个内嵌函数
2. 内嵌函数必须引用外部函数中的变量
3. 外部函数的返回值必须是内嵌函数

```python
def outer_func():
    loc_list = []
    def inner_func(name):
        loc_list.append(len(loc_list) + 1)
        print '%s loc_list = %s' %(name, loc_list)
    return inner_func
```

重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.
闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.

# 21 lambda函数

作者：涛吴
链接：https://www.zhihu.com/question/20125256/answer/14058285
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

有实际用途的匿名函数。先举一个普通的 Python 例子：将一个 list 里的每个元素都平方：
```python
map( lambda x: x*x, [y for y in range(10)] )
```
这个写法要好过
```python
def sq(x):
    return x * x
map(sq, [y for y in range(10)])
```
因为后者多定义了一个（污染环境的）函数，尤其如果这个函数只会使用一次的话。
而且第一种写法实际上更易读，因为那个映射到列表上的函数具体是要做什么，非常一目了然。
如果你仔细观察自己的代码，会发现这种场景其实很常见：你在某处就真的只需要一个能做一件事情的函数而已，连它叫什么名字都无关紧要。Lambda 表达式就可以用来做这件事。

进一步讲，匿名函数本质上就是一个函数，它所抽象出来的东西是一组运算。
类比
```python
a = [1, 2, 3]
```
和
```python
f = lambda x : x + 1
```
你会发现，等号右边的东西完全可以脱离等号左边的东西而存在，等号左边的名字只是右边之实体的标识符。如果你能习惯 [1, 2, 3] 单独存在，那么 lambda x : x + 1 也能单独存在其实也就不难理解了，它的意义就是给「某个数加一」这一运算本身。

# 22 Python函数式编程

这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.

推荐: [酷壳](http://coolshell.cn/articles/10822.html)

python中函数式编程支持:

filter 函数的功能相当于过滤器。调用一个布尔函数`bool_func`来迭代遍历每个seq中的元素；返回一个使`bool_seq`返回值为true的元素的序列。

```python
>>>a = [1,2,3,4,5,6,7]
>>>b = filter(lambda x: x > 5, a)
>>>print b
>>>[6,7]
```

map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：

```python
>>> a = map(lambda x:x*2,[1,2,3])
>>> list(a)
[2, 4, 6]
```

reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：

```python
>>> reduce(lambda x,y:x*y,range(1,4))
6
```

# 23 Python里的拷贝

引用和copy(),deepcopy()的区别

```python
import copy
a = [1, 2, 3, 4, ['a', 'b']]  #原始对象

b = a  #赋值，传对象的引用
c = copy.copy(a)  #对象拷贝，浅拷贝
d = copy.deepcopy(a)  #对象拷贝，深拷贝

a.append(5)  #修改对象a
a[4].append('c')  #修改对象a中的['a', 'b']数组对象

print 'a = ', a
print 'b = ', b
print 'c = ', c
print 'd = ', d

输出结果：
a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
c =  [1, 2, 3, 4, ['a', 'b', 'c']]
d =  [1, 2, 3, 4, ['a', 'b']]
```

浅拷贝（shallowCopy）只是对象中的引用增加了一个指针指向已存在的内存地址，

深拷贝（deepCopy）是对象中的引用增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存

# 24 Python垃圾回收机制

Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。

### 1 引用计数

PyObject是每个对象必有的内容，其中`ob_refcnt`就是做为引用计数。当一个对象有新的引用时，它的`ob_refcnt`就会增加，当引用它的对象被删除，它的`ob_refcnt`就会减少.引用计数为0时，该对象生命就结束了。

优点:

1. 简单
2. 实时性

缺点:

1. 维护引用计数消耗资源
2. 循环引用

### 2 标记-清除机制

基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。

### 3 分代技术

分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。

Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

举例：
当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。

# 26 Python的is

is是对比地址,==是对比值

# 27 read,readline和readlines

* read        读取整个文件
* readline    读取下一行,使用生成器方法
* readlines   读取整个文件到一个迭代器以供我们遍历

# 28 super()._init__()

此时A已经成功继承了父类的属性，所以super().__init__()的作用也就显而易见了，就是执行父类的构造函数，使得我们能够调用父类的属性。

# 29 range and xrange
都在循环时使用，xrange内存性能更好。
xrange的用法与range相同，即xrange([start,] stop[, step])根据start与stop指定的范围以及step设定的步长,他所不同的是xrange并不是生成序列，而是作为一个生成器。即他的数据生成一个取出一个。

所以相对来说，xrange比range性能优化很多，因为他不需要一下子开辟一块很大的内存，特别是数据量比较大的时候。

注意：1、xrange和range这两个基本是使用在循环的时候。
2、 当需要输出一个列表的时候，就必须要使用range了。

# 30 什么是PEP?

PEP代表Python Enhancement Proposal。它是一组规则，指定如何格式化Python代码以获得最大可读性。

# 31 Python内存管理机制
python中的内存管理由Python私有堆空间管理。所有Python对象和数据结构都位于私有堆中(CPython)。程序员无权访问此私有堆。python解释器负责处理这个问题。
## 内存池
Python的内存机制是金字塔型，-1，-2层主要由操作系统进行操作，第0层是C中的malloc，free等内存分配和释放函数进行操作；是操作系统提供的内存管理接口，Python 不能干涉这一层的行为。剩余的 3 层都是由 Python 实现并维护的。
在第 1 层，是 Python 基于第 0 层操作系统的内存管理接口包装而成的。以 PyMem_为前缀的函数族。
在第 2 层，对 Python 中的一些常用对象的内存管理，比如整数对象、字符串对象，这里是内存池。
在第 3 层，主要是对象缓冲池机制。
真正在 Python 中发挥巨大作用的，是第 2 层的内存管理机制。这部分包括了 GC。
关于释放内存方面，当一个对象的引用计数变为0时，Python就会调用它的析构函数。调用析构函数并不意味着最终一定会调用free来释放内存空间，如果真是这样的话，那频繁地申请、释放内存空间会使Python的执行效率大打折扣。因此在析构时也采用了内存池机制，从内存池申请到的内存会被归还到内存池中，以避免频繁地申请和释放动作。
Python内部默认的小块内存与大块内存的分界点定在256个字节，当申请的内存小于256字节时，PyObject_Malloc会在内存池中申请内存；当申请的内存大于256字节时，PyObject_Malloc的行为将蜕化为malloc的行为。当然，通过修改Python源代码，我们可以改变这个默认值，从而改变Python的默认内存管理行为。
![97207-qfew8ky6prt.png](http://www.sukidesu.top/usr/uploads/2020/10/2431582095.png)

## 对象缓冲池
缓冲池实际上就是当python解释器启动时所开辟内存空间中的一部分,用于存储高频使用的对象
### 小整数对象池
整数在程序中的使用非常广泛，Python为了优化速度，使用了小整数对象池， 避免为整数频繁申请和销毁内存空间。Python 对小整数的定义是 [-5, 256] 这些整数对象是提前建立好的，不会被垃圾回收。在一个 Python 的程序中，无论这个整数处于LEGB中的哪个位置，所有位于这个范围内的整数使用的都是同一个对象。
### intern机制
没有空格的字符串复用机会大，所以只创建一次，有空格会创建多次，但是字符串长度大于20，会创建多次.
```python
a="helloworld"
b="helloworld"
a is b #True
```
### 大整数对象池
超出小整数的范围即为大整数，每次都会创建一个新的对象。但是处于一个代码块的大整数是同一个对象。终端是每次执行一次，所以每次的大整数都重新创建，而在pycharm中，每次运行是所有代码都加载都内存中，属于一个整体，所以这个时候会有一个大整数对象池，即处于一个代码块的大整数是同一个对象。c1 和d1 处于一个代码块，而c1.b和c2.b分别有自己的代码块，所以不相等。
```python
c1 = 1000
d1 = 1000
print(c1 is d1)  # True
class C1(object):
    a = 100
    b = 100
    c = 1000
    d = 1000
class C2(object):
    a = 100
    b = 1000
print(C1.a is C1.b)  # True
print(C1.a is C2.a)  # True
print(C1.c is C1.d)  # True
print(C1.b is C2.b)  # False
```

### 可变对象
可变对象不可能使用缓冲池,因可变对象随时可变,缓存是没有意义的

# 32 \_\_name\_\_ 和 \_\_main\_\_
\_\_name\_\_ 是当前模块名，当模块被直接运行时模块名为 \_\_main\_\_ 。这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。

我们知道，当我们把模块A中的代码在模块B中进行import A时，只要B模块代码运行到该import语句，模块A的代码会被执行。
模块A：
```python
# 模块A
a = 100
print('你好，我是模块A……')
print(a)
```
模块B：
```python
# 模块B
from package01 import A
b = 200
print('你好，我是模块B……')
print(b)
```
运行模块B时，输出结果如下：
　　

    你好，我是模块A……
    100
    你好，我是模块B……
    200

如果在模块A中，我们有部分的代码不想在被导入到B时直接被运行，但在直接运行A时可直接运行，那该怎么做呢？那就可以用到“if __name__==’__main__:”这行代码了，我们队上面用到的A模块代码进行修改：
A模块代码修改为：
```python
# 模块A
a = 100
print('你好，我是模块A……')
if __name__=='__main__':
    print(a)
```
B模块不做修改，直接执行B模块，输出结果如下：
　　

    你好，我是模块A……
    你好，我是模块B……
    200

　　看到了吗，A模块中的a的值就没有再被输出了。所以，当你要导入某个模块，但又不想改模块的部分代码被直接执行，那就可以这一部分代码放在“if \_\_name__=='\_\_main\_\_':”内部。

# 33.Python中help()和dir()函数的用法是什么？
help()和dir()这两个函数都可以从Python解释器直接访问，并用于查看内置函数的合并转储。
help()函数：help()函数用于显示文档字符串，还可以查看与模块，关键字，属性等相关的使用信息。
dir()函数：dir()函数用于显示定义的符号。

# 34. 当退出 Python 时，是否释放全部内存？
答案是 No。循环引用其它对象或引用自全局命名空间的对象的模块，在 Python 退出时并非完全释放。
另外，也不会释放 C 库保留的内存部分。退出时，由于拥有自己的高效清理机制，Python会尝试取消分配/销毁其他所有对象。


  [1]: https://www.cnblogs.com/tkqasn/p/6524879.html
  [2]: https://www.runoob.com/w3cnote/python-func-decorators.html
  
