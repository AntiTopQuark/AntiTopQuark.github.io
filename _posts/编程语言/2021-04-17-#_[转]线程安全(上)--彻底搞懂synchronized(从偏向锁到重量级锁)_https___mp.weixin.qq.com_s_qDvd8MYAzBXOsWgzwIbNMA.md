---
layout: post
cid: 98
title: # [转]线程安全(上)--彻底搞懂synchronized(从偏向锁到重量级锁) https://mp.weixin.qq.com/s/qDvd8MYAzBXOsWgzwIbNMA
slug: 98
date: 2021/04/17 17:25:00
updated: 2021/04/17 17:31:42
status: publish
author: AntiTopQuark
categories: 
  - 编程语言
tags: 
  - 类型
  - 实例
  - 方法
  - 内存
  - 存储
  - 用户
  - 状态
  - 线程
  - 对象
  - 数据
  - 操作
  - 记录
  - 过程
  - 原理
  - 锁
  - 区别
  - 内核
  - 步骤
  - 问题
  - java
  - 虚拟
  - public
  - 偏向
  - 轻量级
customSummary: 
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---


# [转]线程安全(上)--彻底搞懂synchronized(从偏向锁到重量级锁) https://mp.weixin.qq.com/s/qDvd8MYAzBXOsWgzwIbNMA

接触过线程安全的同学想必都使用过synchronized这个关键字，在java同步代码快中，synchronized的使用方式无非有两个:

1. 通过对一个对象进行加锁来实现同步，如下面代码。

```java
synchronized(lockObject){    //代码}
```

1. 对一个方法进行synchronized声明，进而对一个方法进行加锁来实现同步。如下面代码

```java
public synchornized void test(){
    //代码
}
```

但这里需要指出的是，无论是对一个对象进行加锁还是对一个方法进行加锁，实际上，都是对**对象进行加锁**。

也就是说，对于方式2，实际上虚拟机会根据synchronized修饰的是实例方法还是类方法，去取对应的实例对象或者Class对象来进行加锁。

对于synchronized这个关键字，可能之前大家有听过，他是一个**重量级锁**，开销很大，建议大家少用点。但大家可能也听说过，但到了jdk1.6之后，该关键字被进行了很多的优化，已经不像以前那样不给力了，建议大家多使用。

那么它是进行了什么样的优化，才使得synchronized又深得人心呢？为何重量级锁开销就大呢？

想必大家也都听说过轻量级锁，重量级锁，自旋锁，自适应自旋锁，偏向锁等等，他们都有哪些区别呢？

#### 锁对象

刚才我们说，锁实际上是加在对象上的，那么被加了锁的对象我们称之为**锁对象**，在java中，任何一个对象都能成为锁对象。

为了让大家更好着理解虚拟机是如何知道这个对象就是一个锁对象的，我们下面简单介绍一下java中一个对象的结构。

java对象在内存中的存储结构主要有一下三个部分：

1. 对象头
2. 实例数据
3. 填充数据

这里强调一下，**对象头**里的数据主要是一些运行时的数据。

其简单的结构如下

| 长度     | 内容                   | 说明                        |
| -------- | ---------------------- | --------------------------- |
| 32/64bit | Mark Work              | hashCode,GC分代年龄，锁信息 |
| 32/64bit | Class Metadata Address | 指向对象类型数据的指针      |
| 32/64bit | Array Length           | 数组的长度(当对象为数组时)  |

从该表格中我们可以看到，对象中关于锁的信息是存在Markword里的。

从该表格中我们可以看到，对象中关于锁的信息是存在Markword里的。

我们来看一段代码

```java
LockObject lockObject = new LockObject();//随便创建一个对象

synchronized(lockObject){
    //代码
}
```

当我们创建一个对象LockObject时，该对象的部分Markword关键数据如下。

| bit fields | 是否偏向锁 | 锁标志位 |
| ---------- | ---------- | -------- |
| hash       | 0          | 01       |

从图中可以看出，**偏向锁**的标志位是“01”，状态是“0”，表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。该对象被创建出来的那一刻，就有了偏向锁的标志位，这也说明了所有对象都是可偏向的，但所有对象的状态都为“0”，也同时说明所有被创建的对象的偏向锁并没有生效。

#### 偏向锁

不过，当线程执行到临界区（critical section）时，此时会利用CAS(Compare and Swap)操作，将线程ID插入到Markword中，同时修改偏向锁的标志位。

> 所谓临界区，就是只允许一个线程进去执行操作的区域，即同步代码块。CAS是一个原子性操作

此时的Mark word的结构信息如下：

| bit fields |       | 是否偏向锁 | 锁标志位 |
| ---------- | ----- | ---------- | -------- |
| threadId   | epoch | 1          | 01       |

此时偏向锁的状态为“1”，说明对象的偏向锁生效了，同时也可以看到，哪个线程获得了该对象的锁。

##### 那么，什么是偏向锁?

偏向锁是jdk1.6引入的一项锁优化，其中的“偏”是偏心的偏。它的意思就是说，**这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。**

也就是说:

在此线程之后的执行过程中，如果再次进入或者退出同一段同步块代码，并不再需要去进行**加锁**或者**解锁**操作，而是会做以下的步骤：

1. Load-and-test，也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致.
2. 如果一致，则说明此线程已经成功获得了锁，继续执行下面的代码.
3. 如果不一致，则要检查一下对象是否还是可偏向，即“是否偏向锁”标志位的值。
4. 如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。

如果此对象已经偏向了，并且不是偏向自己，则说明存在了**竞争**。此时可能就要根据另外线程的情况，可能是重新偏向，也有可能是做偏向撤销，但大部分情况下就是升级成**轻量级锁**了。

可以看出，偏向锁是针对于一个线程而言的，线程获得锁之后就不会再有解锁等操作了，这样可以省略很多开销。假如有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁了。

为什么要这样做呢？因为经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的。这也是为什么会有偏向锁出现的原因。

**在Jdk1.6中，偏向锁的开关是默认开启的，适用于只有一个线程访问同步块的场景。**

#### 锁膨胀

刚才说了，当出现有两个线程来竞争锁的话，那么偏向锁就失效了，此时锁就会膨胀，升级为轻量级锁。这也是我们经常所说的**锁膨胀**

#### 锁撤销

由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：

1. 在一个安全点停止拥有锁的线程。
2. 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。
3. 唤醒当前线程，将当前锁升级成轻量级锁。

所以，**如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭。**

#### 轻量级锁

锁撤销升级为轻量级锁之后，那么对象的Markword也会进行相应的的变化。下面先简单描述下锁撤销之后，升级为轻量级锁的过程：

1. 线程在自己的栈桢中创建锁记录 LockRecord。
2. 将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。
3. 将锁记录中的Owner指针指向锁对象。
4. 将锁对象的对象头的MarkWord替换为指向锁记录的指针。



对应的图描述如下(图来自周志明深入java虚拟机)

1.

![图片](https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINibSYoa92T3L2GonPIrTg7zzykdbNaMlt5mqBsvWLOQOxD0hp25RFtYD9AwgYmebakictyO1viajcGg/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

2.

![图片](https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzINibSYoa92T3L2GonPIrTg7ztnfe4iaicEyXcmyp6CuOOAlrJicP5Bu0hlzU2HVAdIKWqYM8raSnvq6og/640?tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



之后Markwork如下：

| bit fields           | 锁标志位 |
| -------------------- | -------- |
| 指向LockRecord的指针 | 00       |

**注：锁标志位”00”表示轻量级锁**

轻量级锁主要有两种

1. 自旋锁
2. 自适应自旋锁

##### 自旋锁

**所谓自旋，就是指当有另外一个线程来竞争锁时，这个线程会在原地循环等待，而不是把该线程给阻塞，直到那个获得锁的线程释放锁之后，这个线程就可以马上获得锁的。**

**注意，锁在原地循环的时候，是会消耗cpu的，就相当于在执行一个啥也没有的for循环。**

所以，轻量级锁适用于那些同步代码块执行的很快的场景，这样，线程原地等待很短很短的时间就能够获得锁了。

经验表明，大部分同步代码块执行的时间都是很短很短的，也正是基于这个原因，才有了轻量级锁这么个东西。

###### 自旋锁的一些问题

1. 如果同步代码块执行的很慢，需要消耗大量的时间，那么这个时侯，其他线程在原地等待空消耗cpu，这会让人很难受。
2. 本来一个线程把锁释放之后，当前线程是能够获得锁的，但是假如这个时候有好几个线程都在竞争这个锁的话，那么有可能当前线程会获取不到锁，还得原地等待继续空循环消耗cup，甚至有可能一直获取不到锁。

基于这个问题，我们必须给**线程空循环设置一个次数，当线程超过了这个次数，我们就认为，继续使用自旋锁就不适合了，此时锁会再次膨胀，升级为重量级锁。**

**默认情况下，自旋的次数为10次，**用户可以通过-XX:PreBlockSpin来进行更改。

> 自旋锁是在JDK1.4.2的时候引入的

##### 自适应自旋锁

**所谓自适应自旋锁就是线程空循环等待的自旋次数并非是固定的，而是会动态着根据实际情况来改变自旋等待的次数。**

其大概原理是这样的：

假如一个线程1刚刚成功获得一个锁，当它把锁释放了之后，线程2获得该锁，并且线程2在运行的过程中，此时线程1又想来获得该锁了，但线程2还没有释放该锁，所以线程1只能自旋等待，但是虚拟机认为，**由于线程1刚刚获得过该锁，那么虚拟机觉得线程1这次自旋也是很有可能能够再次成功获得该锁的，所以会延长线程1自旋的次数**。

另外，如果对于某一个锁，一个线程自旋之后，很少成功获得该锁，那么以后这个线程要获取该锁时，是有可能直接忽略掉自旋过程，直接升级为重量级锁的，以免空循环等待浪费资源。

> 轻量级锁也被称为**非阻塞同步**、**乐观锁**，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。

#### 重量级锁

轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为**互斥锁**。

当轻量级所经过锁撤销等步骤升级为重量级锁之后，它的Markword部分数据大体如下

| bit fields      | 锁标志位 |
| --------------- | -------- |
| 指向Mutex的指针 | 10       |

##### 为什么说重量级锁开销大呢

**主要是，当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。**

这就是说为什么重量级线程开销很大的。

> 互斥锁(重量级锁)也称为**阻塞同步**、**悲观锁**

#### 总结

通过上面的分析，我们知道了为什么synchronized关键字为何又深得人心，也知道了锁的演变过程。

也就是说，synchronized关键字并非一开始就该对象加上重量级锁，也是从偏向锁，轻量级锁，再到重量级锁的过程。

这个过程也告诉我们，假如我们一开始就知道某个同步代码块的竞争很激烈、很慢的话，那么我们一开始就应该使用重量级锁了，从而省掉一些锁转换的开销。

## volatile关键字

#### 可见性

##### 什么是可见性？

**意思就是说，在多线程环境下，某个共享变量如果被其中一个线程给修改了，其他线程能够立即知道这个共享变量已经被修改了，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的工作空间中读取**

例如我们上面说的，当线程1对t进行了加1操作并把数据写回到主存之后，线程2就会知道它自己工作空间内的t已经被修改了，当它要执行加1操作之后，就会去主存中读取。这样，两边的数据就能一致了。

假如一个变量被声明为volatile，那么这个变量就具有了**可见性**的性质了。这就是volatile关键的作用之一了。

##### volatile保证变量可见性的原理

当一个变量被声明为volatile时，在编译成会变指令的时候，会多出下面一行：

```
0x00bbacde: lock add1 $0x0,(%esp);
```

**这句指令的意思就是在寄存器执行一个加0的空操作。不过这条指令的前面有一个lock(锁)前缀。**

当处理器在处理拥有lock前缀的指令时：

在之前的处理中，lock会导致传输数据的总线被锁定，其他处理器都不能访问总线，从而保证处理lock指令的处理器能够独享操作数据所在的内存区域，而不会被其他处理所干扰。

但由于总线被锁住，其他处理器都会被堵住，从而影响了多处理器的执行效率。为了解决这个问题，在后来的处理器中，处理器遇到lock指令时不会再锁住总线，而是会检查数据所在的内存区域，如果该数据是在处理器的内部缓存中，则会锁定此缓存区域，处理完后把缓存写回到主存中，并且会利用**缓存一致性协议**来保证其他处理器中的缓存数据的一致性。

##### 缓存一致性协议

刚才我在说可见性的时候，说“如果一个共享变量被一个线程修改了之后，当其他线程要读取这个变量的时候，最终会去内存中读取，而不是从自己的**工作空间**中读取”，实际上是这样的：

线程中的处理器会一直在总线上嗅探其内部缓存中的内存地址在其他处理器的操作情况，一旦嗅探到某处处理器打算修改其内存地址中的值，而该内存地址刚好也在自己的内部缓存中，那么处理器就会强制让自己对该缓存地址的无效。所以当该处理器要访问该数据的时候，由于发现自己缓存的数据无效了，就会去主存中访问。

#### 有序性

实际上，当我们把代码写好之后，虚拟机不一定会按照我们写的代码的顺序来执行。例如对于下面的两句代码：

```
int a = 1;
int b = 2;
```

对于这两句代码，你会发现无论是先执行a = 1还是执行b = 2，都不会对a,b最终的值造成影响。所以虚拟机在编译的时候，是有可能把他们进行**重排序**的。

为什么要进行重排序呢？

你想啊，假如执行 int a = 1这句代码需要100ms的时间，但执行int b = 2这句代码需要1ms的时间，并且先执行哪句代码并不会对a,b最终的值造成影响。那当然是先执行int b = 2这句代码了。

所以，虚拟机在进行代码编译优化的时候，对于那些改变顺序之后不会对最终变量的值造成影响的代码，是有可能将他们进行重排序的。

那么重排序之后真的不会对代码造成影响吗？

实际上，对于有些代码进行重排序之后，虽然对变量的值没有造成影响，但有可能会出现线程安全问题的。具体请看下面的代码

```java
public class NoVisibility{
    private static boolean ready;
    private static int number;

    private static class Reader extends Thread{
        public void run(){
        while(!ready){
            Thread.yield();
        }
        System.out.println(number);

    }
}
    public static void main(String[] args){
        new Reader().start();
        number = 42;
        ready = true;
    }
}
```

这段代码最终打印的一定是42吗？如果没有重排序的话，打印的确实会是42，但如果number = 42和ready = true被进行了重排序，颠倒了顺序，那么就有可能打印出0了，而不是42。（因为number的初始值会是0).

因此，重排序是有可能导致线程安全问题的。

**如果一个变量被声明volatile的话，那么这个变量不会被进行重排序，也就是说，虚拟机会保证这个变量之前的代码一定会比它先执行，而之后的代码一定会比它慢执行。**

例如把上面中的number声明为volatile，那么number = 42一定会比ready = true先执行。

> 不过这里需要注意的是，虚拟机只是保证这个变量之前的代码一定比它先执行，但并没有保证这个变量之前的代码不可以重排序。之后的也一样。

**volatile关键字能够保证代码的有序性，这个也是volatile关键字的作用。**

总结一下，一个被volatile声明的变量主要有以下两种特性保证保证线程安全。

1. 可见性。
2. 有序性。

####  

#### volatile真的能完全保证一个变量的线程安全吗？

我们通过上面的讲解，发现volatile关键字还是挺有用的，不但能够保证变量的可见性，还能保证代码的有序性。

那么，它真的能够保证一个变量在多线程环境下都能被正确的使用吗？

答案是否定的。原因是因为Java里面的运算并非是**原子操作**。

##### 原子操作

**原子操作**：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

也就是说，处理器要嘛把这组操作全部执行完，中间不允许被其他操作所打断，要嘛这组操作不要执行。

刚才说Java里面的运行并非是原子操作。我举个例子，例如这句代码

```
int a = b + 1;
```

处理器在处理代码的时候，需要处理以下三个操作：

1. 从内存中读取b的值。
2. 进行a = b + 1这个运算
3. 把a的值写回到内存中



而这三个操作处理器是不一定就会连续执行的，有可能执行了第一个操作之后，处理器就跑去执行别的操作的。

#####  

##### 证明volatile无法保证线程安全的例子

由于Java中的运算并非是原子操作，所以导致volatile声明的变量无法保证线程安全。

对于这句话，我给大家举个例子。代码如下:

```java
public class Test{
    public static volatile int t = 0;

    public static void main(String[] args){

        Thread[] threads = new Thread[10];
        for(int i = 0; i < 10; i++){
            //每个线程对t进行1000次加1的操作
            threads[i] new Thread(new Runnable(){
                @Override
                public void run(){
                    for(int j = 0; j < 1000; j++){
                        t = t + 1;
                    }
                }
            });
            threads[i].start();
        }

        //等待所有累加线程都结束
        while(Thread.activeCount() > 1){
            Thread.yield();
        }

        //打印t的值
        System.out.println(t);
    }
}
```

最终的打印结果会是1000 * 10 = 10000吗？答案是否定的。

问题就出现在t = t + 1这句代码中。我们来分析一下

例如：

线程1读取了t的值，假如t = 0。之后线程2读取了t的值，此时t = 0。

然后线程1执行了加1的操作，此时t = 1。但是这个时候，处理器还没有把t = 1的值写回主存中。这个时候处理器跑去执行线程2，注意，刚才线程2已经读取了t的值，所以这个时候并不会再去读取t的值了，所以此时t的值还是0，然后线程2执行了对t的加1操作，此时t =1 。

这个时候，就出现了线程安全问题了，两个线程都对t执行了加1操作，但t的值却是1。所以说，volatile关键字并不一定能够保证变量的安全性。

  

#### 什么情况下volatile能够保证线程安全

刚才虽然说，volatile关键字不一定能够保证线程安全的问题，其实，在大多数情况下volatile还是可以保证变量的线程安全问题的。所以，在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：

1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
2. 变量不需要与其他状态变量共同参与不变约束。


# volatile和synchronized的区别
1. volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2. volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
3. volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
3. volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
4. volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化