---
layout: post
cid: 68
title: JVM 内存模型与类加载机制
slug: 68
date: 2021/04/13 20:28:45
updated: 2021/04/13 20:28:45
status: publish
author: AntiTopQuark
categories: 
  - 编程语言
tags: 
  - 反射
  - 类型
  - 逻辑
  - 函数
  - 通道
  - 变量
  - 实例
  - 程序
  - 方法
  - 编译
  - 语言
  - 内存
  - 系统
  - 存储
  - 用户
  - 错误
  - 对象
  - 文件
  - 数据
  - 操作
  - 方法区
  - 模型
  - jvm
  - class
  - 过程
  - 索引
  - 参数
  - 表
  - null
  - o
  - false
  - 标记
  - 搜索
  - return
  - 程序员
  - 处理
  - 问题
  - 算法
  - 动作
  - java
  - 虚拟
customSummary: 
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---



# 内存模型
JVM内存模型可以分为两个部分，如下图所示，堆和方法区是所有线程共有的，而虚拟机栈，本地方法栈和程序计数器则是线程私有的。
![52360-p8pzc60avte.png](http://www.sukidesu.top/usr/uploads/2020/10/2133361642.png)

### 堆Heap

堆内存是所有线程共有的，可以分为两个部分：年轻代和老年代。下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代也将被移除。
![53982-8s5ewsc8t5f.png](http://www.sukidesu.top/usr/uploads/2020/10/3525061659.png)
堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，该内存区域存放了对象实例及数组（但不是所有的对象实例都在堆中）。
其大小通过-Xms(最小值)和-Xmx(最大值)参数设置（最大最小值都要小于1G），前者为启动时申请的最小内存，默认为操作系统物理内存的1/64，后者为JVM可申请的最大内存,默认为物理内存的1/4，默认当空余堆内存小于40%时，JVM会增大堆内存到-Xmx指定的大小，可通过-XX:MinHeapFreeRation=来指定这个比列；当空余堆内存大于70%时，JVM会减小堆内存的大小到-Xms指定的大小，可通过XX:MaxHeapFreeRation=来指定这个比列，当然为了避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。
在我们垃圾回收的时候，我们往往将堆内存分成新生代和老生代（大小比例1：2），新生代中由Eden和Survivor0，Survivor1组成，三者的比例是8：1：1，新生代的回收机制采用复制算法，在Minor GC的时候，我们都留一个存活区用来存放存活的对象，真正进行的区域是Eden+其中一个存活区，当我们的对象时长超过一定年龄时（默认15，可以通过参数设置），将会把对象放入老生代，当然大的对象会直接进入老生代。老生代采用的回收算法是标记整理算法。

### 方法区（Method Area）

方法区也称”永久代“，它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。默认最小值为16MB，最大值为64MB（64位JVM由于指针膨胀，默认是85M），可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。它是一片连续的堆空间，永久代的垃圾收集是和老年代(old generation)捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。不过，一个明显的问题是，当JVM加载的类信息容量超过了参数-XX：MaxPermSize设定的值时，应用将会报OOM的错误。参数是通过-XX:PermSize和-XX：MaxPermSize来设定的。
jdk1.7之前：方法区位于永久代(PermGen)，永久代和堆相互隔离，永久代的大小在启动JVM时可以设置一个固定值，不可变；
jdk1.8：仍然保留方法区的概念，只不过实现方式不同。取消永久代，方法存放于元空间(Metaspace)，元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中。

### 虚拟机栈(JVM Stack)

描述的是java方法执行的内存模型：
每个方法被执行的时候都会创建一个”栈帧”,用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。声明周期与线程相同，是线程私有的。
栈帧由三部分组成：局部变量区、操作数栈、帧数据区。局部变量区被组织为以一个字长为单位、从0开始计数的数组，和局部变量区一样，操作数栈也被组织成一个以字长为单位的数组。但和前者不同的是，它不是通过索引来访问的，而是通过入栈和出栈来访问的，可以看作为临时数据的存储区域。除了局部变量区和操作数栈外，java栈帧还需要一些数据来支持常量池解析、正常方法返回以及异常派发机制。这些数据都保存在java栈帧的帧数据区中。
局部变量表: 存放了编译器可知的各种基本数据类型、对象引用(引用指针，并非对象本身)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。

### 本地方法栈(Native Stack)
与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。(栈的空间大小远远小于堆)

### 程序计数器（PC Register）
是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。
### 直接内存
直接内存并不是虚拟机内存的一部分，也不是Java虚拟机规范中定义的内存区域。jdk1.4中新加入的NIO，引入了通道与缓冲区的IO方式，它可以调用Native方法直接分配堆外内存，这个堆外内存就是本机内存，不会影响到堆内存的大小.

# 类加载机制
## 什么是类的加载
jvm将class文读取到内存中，经过对class文件的校验、转换解析、初始化最终在jvm的heap和方法区分配内存形成可以被jvm直接使用的类型的过程。
## 类的生命周期
7个阶段依次为：Loading Verification Preparation Resolution Initialization Using Unloading
![94838-f1ld87gvrmj.png](http://www.sukidesu.top/usr/uploads/2020/10/3178571314.png)

### 加载Loading
这个阶段jvm完成以下动作：
1. 加载器通过类的全路径限定名读取类的二进制字节流，
2. 将二进制字节流代表的类结构转化到运行时数据区的 方法区中，
3. 在jvm堆中生成代表这个类的java.lang.Class实例(不是这个类的实例)

JVM提供了三个类加载器：
- Bootstrap classLoader:主要负责加载核心的类库(java.lang.*等)，构造ExtClassLoader和APPClassLoader。
- ExtClassLoader：主要负责加载jre/lib/ext目录下的一些扩展的jar。
- AppClassLoader：主要负责加载应用程序的主函数类
![21444-rdxo2i1ioxr.png](http://www.sukidesu.top/usr/uploads/2020/10/247165364.png)
#### 双亲委派机制
双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。
双亲委派机制的作用：
1、保证安全性：防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
2、保证唯一性：保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。

试想，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，多个类加载器都去加载这个类到内存中，系统中将会出现多个不同的Object类，那么类之间的比较结果及类的唯一性将无法保证，因为Object都各不相同那么程序运行启动就会出错，也保证了JVM能够正常的安全运行。

![75078-el7bej7qpum.png](http://www.sukidesu.top/usr/uploads/2020/10/2200186546.png)
```Java
public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
    //              -----??-----
    protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }
 
                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            return c;
    }
```

### 验证verification
Loading和 验证是交叉进行的，验证二进制字节流代表的字节码文件是否合格，主要从一下几方面判断：
文件格式：参看class文件格式详解，经过文件格式验证之后的字节流才能进入方法区分配内存来存储。
元数据验证：是否符合java语言规范
字节码验证：数据流和控制流的分析，这一步最复杂
符号引用验证：符号引用转化为直接引用时（解析阶段），检测对类自身以外的信息进行存在性、可访问性验证
如果确认代码安全无误，可用 -Xverify:none关闭大部分类的验证，加快类加载时间

### 准备preparation
在方法区中给类的类变量(static修饰)分配内存
然后初始化其值，如果类变量是常量，则直接赋值为该常量值否则为java类型的默认的零值。

### 解析resolution
指将常量池内的符号引用替换为直接引用的过程。

### 初始化initialization
这个阶段才真正开始执行java代码，静态代码块和设置变量的初始值为程序员设定的值
有且只有下面5种情况才会立即初始化类，称为主动引用：
1. new 对象时
2. 读取或设置类的静态字段（除了被final，已在编译期把结果放入常量池的静态字段）或调用类的静态方法时；
3. 用java.lang.reflect包的方法对类进行反射调用没初始化过的类时
4. 初始化一个类时发现其父类没初始化，则要先初始化其父类
5. 含main方法的那个类，jvm启动时，需要指定一个执行主类，jvm先初始化这个类

其他对类的引用 称为被动引用，加载类时不会进行初始化动作

子类继承父类时的初始化顺序
   1.首先初始化父类的static变量和块，按出现顺序
   2.初始化子类的static变量和块，按出现顺序
   3.初始化父类的普通变量，调用父类的构造函数
   4.初始化子类的普通变量，调用子类的构造函数

类的初始化过程发生时刻： 
1. T是一个类，当T的一个实例创建的时候，也就是T t = new T（）; 
2. T的一个静态方法被调用的时候，也就是 T.staticField（）; 
3. T的静态属性被赋值的时候，T.staticField = o; 
4. T的一个静态属性被使用的时候，也就是 Object o = T.staticField; 但是它不是常量。 
5. T is a top level class , and an assert statement lexically nested 

