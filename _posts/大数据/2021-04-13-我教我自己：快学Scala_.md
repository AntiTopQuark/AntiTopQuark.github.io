---
layout: post
cid: 45
title: 我教我自己：快学Scala 
slug: 45
date: 2021/04/13 17:40:23
updated: 2021/04/13 17:40:23
status: publish
author: AntiTopQuark
categories: 
  - 大数据
  - 编程语言
tags: 
  - 类型
  - 函数
  - 变量
  - 程序
  - int
  - 方法
  - 编译
  - 语句
  - print
  - 对象
  - 操作
  - 过程
  - null
  - 字符
  - return
  - scala
  - val
  - 转换
  - 问题
customSummary: 
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---



<!-- index-menu -->
# 第一章 基础
## 1.1 Scala解释器
Scala解释器读到一个表达式，对它进行求值，将他打印出来，接着再继续下一个表达式。这个过程被称作读取-求值-打印-循环，即REPL。
从技术上讲，Scala程序并不是一个解释器。实际发生的是，你输入的内容被快速地编译成**字节码**，然后这段字节码交由Java虚拟机执行。
## 1.2 声明变量和值
val:常量，不能改变内容
var:变量
**鼓励使用val**
多声明

    val xmax,ymax = 100//xmax,ymax都设为100
    var greeting,message:String = null//greeting message都是字符串
    val a:Int,b:Double = 3 //是错误的
##1.3 常用类型
Scala有七种数值类型：Byte Char Short Int Long Float Double 以及一个Boolean类型
Scala不刻意区分基本类型和引用类型
在Scala中，我们不需要包装类型。在基本类型和包装类型之间的转换是Scala编译器的工作。举例：如果创建一个Int型数组，最终在虚拟机中得到的是一个int[]数组。
Scala用底层的java.lang.String类来表示字符串。不过通过StringOps类给字符串追加了很多操作。

    "Hello" intersect "World" //输出“lo”
在这个表达式中，Java.lang.String对象“Hello”被隐式转换成了一个StringOps对象，接着调用intersect方法。
同样地，Scala还提供了RichInt,RichDouble,RichChar等，为int、double、char提供了便捷方法。
<br>
在Scala中，我们使用类似toInt等to*方法，而不是强制类型转换来做数值类型之间的转换。
## 1.4 算法和操作符重载
1. +-*/%算数操作符，位操作符&|^>><<等仍然是原本操作，这些操作符实际上是方法。例如： a+b => a.+(b) 同时，Scala几乎可以使用任何符号来命名方法。
2. Scala可以使用 a 方法 b 作为 a.方法(b)的缩写。
3. Scala没有++ -- 操作符号，而是使用 += 1 -=1 .注意：无法简单的实现一个命名为++的方法，因为Int类是不可变的，这样一个方法并不能改变某个整数类型的值。
## 1.5 调用函数和方法
1. 使用以scala.开头的包时，我们可以省去scala前缀。例如，import math._等同于 import scala.math._，而math.sqrt(2)等同于scala.math.sqrt(2)
2. Scala没有静态方法。不过有个类似的特性叫单例对象（singleton object）。通常一个类对应有一个伴生对象（companion object）,其方法跟Java中的静态方法一样。
## 1.6 apply方法
1. 在Scala中，我们通常都会使用类似函数调用的语法。举例来说，如果s是一个字符串，那么s(i)表示该字符串的第i个字符。
2. 可以把这种方法当做()操作符的重载形式，他背后的实现原理是apply方法。
3. "Hello"(4)是"Hello".apply(4)的简写；BigInt("1234567890")是BigInt.apply("1234567890")的简写。像这样调用伴生对象的apply方法是Scala中构建对象的常用手法。
## 1.7练习
1. res变量是val
2. take drop takeRight dropRight这些字符串函数的作用：take是从字符串首开始获取字符串，drop是从字符首开始去除字符串。takeRight和dropRight是从字符串尾开始操作。这四个方法都是单方向的。

# 第二章 控制结构和函数
## 2.1条件表达式
1. 在Scala中每个表达式都有一个类型。举例来说，表达式if(x>0)1 else -1的类型Int,因为两个分支的类型都是Int。混合类型表达式：
   if (x>0) "postive" else -1
上述表达式的类型是两个分支类型的公共超类型.在例子中，一个分支类型是java.lang.String 另一个分支是Int。公共超类型是Any。
2. 如果else缺失，那么可能if语句没有输出值。但是**在Scala中，每个表达式都应该有某个值**这个问题的解决方法是引入一个Unit类，写作()。等同于
   if (x>0) 1 else ()
可以把()当做表示“无有用值”的占位符，把Unit当做void。
**注意：从技术上讲，void没有值，但是Unit有一个表示“无值”的值。**
## 2.2块表达式和赋值
1. 在Scala中，{}块包含一系列表达式，其结果也是一个表达式。块中最后一个表达式的值就是块的值。
2. 在Scala中，赋值动作本身没有返回值，准确说是Unit类型 x = y = 1 => x= ()
## 2.3 输入和输出
1. 打印值：print println
2. readLine读取一行输入 需要导入 import scala.io._ 使用方法：Stdin.read****()
## 2.5 循环
1. Scala拥有和java c++相同的while do循环。
2. 在for循环的变量之前并没有val var指定。该变量的类型是集合的元素类型。循环变量的作用域一直持续到循环结束
3. 若需要遍历到 0 n-1 ,使用util方法
4. Scala并没有提供break continue语句退出循环。若需要：1）使用Boolean的控制变量 2）使用嵌套函数，在函数中return 3) 使用break对象的break方法
![93129-omii3h37wr.png](http://www.sukidesu.top/usr/uploads/2020/02/2865514159.png)
在这里，控制权的转移是通过抛出和补货异常完成的，时间影响大。
## 2.6 高级for循环和for推导式
1. 可以使用变量<-表达式的形式提供多个生成器，用；分割
例如：

    for(i <- 1 to 3;j <- 1 to 3) print((10*i+j)+" ")
    // 结果： 11 12 13 21 22 23 31 32 32 相当于两层for循环

2.每个生成器可以带一个if守卫 ***注意：if前面没有分号***

    for(i <- 1 to 3;j <- 1 to 3 if i != j) print((10*i+j)+" ")
    //12 13 21 23 31 32
3.for循环中可以任意多得定义，在循环中引入变量

    for(i<- 1 to 3;from = 4-i;j<- from to 3) print((10*i+j)+" ")
    //打印 13 22 23 31 32 33

4.如果for循环体以yield开始，循环会构造出一个集合，每次迭代以何种的一个元素。这种循环叫做for推导式。

    for( i<- 1 to 10) yield i%3
    res104: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 0, 1, 2, 0, 1, 2, 0, 1)

for推导式生成的集合和它的第一个生成器是类型兼容的

    for( c<-"Hello";i<- 0 to 1) yield (c+i).toChar
    // res105: String = HIeflmlmop
    for( i<- 0 to 1；c<-"Hello") yield (c+i).toChar
    //res106: scala.collection.immutable.IndexedSeq[Char] = Vector(H, e, l, l, o, I, f, m, m, p)
## 2.7 函数
1. 定义： def abs(x:Double) = if(x >= 0) x else -x
2. 必须给出所有的参数类型。只要函数不是递归的，Scala编译器可以通过=符号右侧的表达式的类型推断出返回类型
3. 对于递归函数必须置顶返回类型。

    def fac(n:Int):Int = if(n <= 0) 1 else n*fac(n-1)

## 2.8 默认参数和带名参数
1. 默认参数

    def decorate(str:String,left:String="[",right:String="]") = left + str + right

2.带名参数

    decorate(left = "!!" ,right="**",str="Hello")

## 2.9 变长参数
1.
    def sum(args:Int*)={
     var r = 0
     for(arg <- args) r += arg
     r
    }
    val s = sum(1,3,5,76,87,9)
    // s = 181
2. 如果已经有一个值的序列，不能直接调用上述函数。

    val s= sum( 1 to 5) //错误

正确方法是告诉编译器，希望这个范数被当做参数序列处理。追加 :_*

    val s= sum( 1 to 5 :_*)
3. 在递归定义中，可能遇到上述语法

    def recursiveSum(args :Int*):Int = {
        if (args.length ==0 )0
        else args.head+recursiveSum(args.tail:_*)
    }
## 2.10 过程
Scala对于不返回值的函数有特殊的表示法。如果函数体包含在花括号当中但没有前面的=号，那么返回类型就是Unit。这样的函数被称为过程。
## 2.11 懒值
当val被声明为lazy时，它的初始化将被推迟，直到我们首次对它取值。例如，
lazy val word = scala.io.Source.fromFile("/usr/share/dict/words").mkString
懒值对开销较大的初始化语句而言十分有用。
## 2.12 异常
1.Scala的异常的工作机制和java c++一样。Scala没有受检异常。同时throw有特殊的类型Nothing

    throw new IllegalArgumentException("x shoude not boe negative")
2. 捕获异常的语法采用的是模式匹配的语法
![65557-05a7kd04cy0a.png](http://www.sukidesu.top/usr/uploads/2020/02/1967159403.png)

![75583-18pzc2dtco2.png](http://www.sukidesu.top/usr/uploads/2020/02/1705374380.png)
![20667-wmek4llfn2.png](http://www.sukidesu.top/usr/uploads/2020/02/2202969594.png)


