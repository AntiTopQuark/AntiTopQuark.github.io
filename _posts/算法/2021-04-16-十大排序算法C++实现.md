---
layout: post
cid: 96
title: 十大排序算法C++实现
slug: 96
date: 2021/04/16 22:25:00
updated: 2021/04/16 23:24:04
status: publish
author: AntiTopQuark
categories: 
  - 算法
tags: 
  - int
  - length
  - arr
  - 排序
  - 冒泡
customSummary: 
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---


![](http://www.sukidesu.top/usr/uploads/2021/04/2539266707.png)
### 冒泡排序
```C
// 冒泡排序
// 从小到大
// 时间复杂度 平均 n^2 最好 n 最坏n^2
// 空间复杂度 1
// 内排序，稳定排序
void bubbleSort(int arr[] , int length) {
    for (int i = 0; i < length - 1; ++i) {
        for (int j = i; j < length; ++j) {
            if (arr[i] > arr[j]){
                swap(arr[i],arr[j]);
            }
        }
    }
}
```

### 选择排序
```C
//选择排序
// 时间复杂度 平均 n^2 最好 n^2 最坏n^2
// 空间复杂度 1
// 内排序 不稳定
void selectSort(int arr[], int length) {
    for (int i = 0; i < length; ++i) {
        int minIndex = i;
        for (int j = i; j < length; ++j) {
            if (arr[minIndex] > arr[j]) {
                minIndex = j;
            }
        }
        swap(arr[i], arr[minIndex]);
    }
}
```

### 插入排序
```C
// 插入排序
// 时间复杂度 平均 n^2 最好 n 最坏n^2
// 空间复杂度 1
// 内排序，稳定排序
void insertSort(int arr[], int length) {
    for (int i = 1; i < length; ++i) {
        int preIndex = i - 1;
        int current = arr[i];
        while (preIndex >= 0 && current <= arr[preIndex]) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex + 1] = current;

    }
}
```

### 希尔排序
```C
// 希尔排序
// 时间复杂度 平均 n^1.3 最好 n 最坏n^2
// 空间复杂度 1
// 内排序，不稳定排序
void shellSort(int arr[], int length) {
    for (int step = length / 2; step >= 1; step /= 2) {
        for (int i = step; i < length; ++i) {
            int preIndex = i - step;
            int current = arr[i];
            while (preIndex >= 0 && current <= arr[preIndex]) {
                arr[preIndex + step] = arr[preIndex];
                preIndex -= step;
            }
            arr[preIndex + step] = current;
        }
    }
}
```

### 归并排序
```C
// 归并排序
// 时间复杂度 平均 nlogn 最好 nlogn 最坏 nlogn
// 空间复杂度 n
// 稳定 外排序
void mergeSort(int arr[], int left, int right) {
    if (left >= right) {
        return;
    }
    int mid = (left + right) >> 1;
    mergeSort(arr, left, mid);
    mergeSort(arr, mid + 1, right);
    merge(arr, left, mid, right);

}

void merge(int *arr, int left, int mid, int right) {
    int res[right - left + 1];
    int left_index = left;
    int right_index = mid + 1;
    int index = 0;
    while (left_index <= mid && right_index <= right) {
        if (arr[left_index] < arr[right_index]) {
            res[index] = arr[left_index];
            index++;
            left_index++;
        } else {
            res[index] = arr[right_index];
            index++;
            right_index++;
        }
    }
    while (left_index <= mid) {
        res[index] = arr[left_index];
        index++;
        left_index++;
    }
    while (right_index <= right) {
        res[index] = arr[right_index];
        index++;
        right_index++;
    }
    for (int i = 0; i < right - left + 1; ++i) {
        arr[left + i] = res[i];
    }
}
```
### 快速排序
```C
// 快速排序
// 时间复杂度 平均nlogn 最好nlogn 最坏 n^2
// 空间复杂度 logn
// 内排序 不稳定
void quickSort(int arr[], int left, int right) {
    if (left >= right) {
        return;
    }
    int p = arr[left];
    int low = left, high = right;
    while (low < high) {
        while (low < high && arr[high] >= p) high--;
        arr[low] = arr[high];
        while (low < high && arr[low] <= p) low++;
        arr[high] = arr[low];
    }
    arr[low] = p;
    quickSort(arr, left, low - 1);
    quickSort(arr, low + 1, right);
}
```

### 堆排序
```C
// 堆排序
// 时间复杂度 平均nlogn 最好nlogn 最坏 nlogn
// 空间复杂度 1
// 内排序 不稳定
void heapify(int arr[], int i, int length) {
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    int max_index = i;
    if (left < length && arr[max_index] < arr[left]) {
        max_index = left;
    }
    if (right < length && arr[max_index] < arr[right]) {
        max_index = right;
    }
    if (max_index != i) {
        swap(arr[i], arr[max_index]);
        heapify(arr, max_index, length);
    }

}

void heap_sort(int arr[], int length) {
    for (int i = length / 2 - 1; i >= 0; --i) {
        heapify(arr, i, length);
    }// 构建小顶堆
    for (int i = length - 1; i > 0; --i) {
        swap(arr[0], arr[i]);
        heapify(arr, 0, i);
    }

}
```