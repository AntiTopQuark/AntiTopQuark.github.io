---
layout: post
cid: 52
title: 项目-音乐推荐网站
slug: 52
date: 2021/04/13 17:46:38
updated: 2021/04/13 17:46:38
status: publish
author: AntiTopQuark
categories: 
  - 项目介绍
tags: 
  - 函数
  - 接口
  - 变量
  - 程序
  - 引擎
  - 界面
  - 用户
  - Python
  - hdfs
  - 任务
  - 数据
  - join
  - 框架
  - 模型
  - 服务器
  - mysql
  - log
  - 梯度
  - 环境
  - unix
  - linux
  - val
  - livy
  - count
  - user_id
  - deepcf
  - 定时
  - 算法
customSummary: 
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---



<!-- index-menu -->
# 环境搭建

部署环境：Hadoop Spark Zeppelin Livy Mysql

# 前端
使用了老师的HTML的登录页面，自己实现了音乐播放的界面，使用Jinja2模板引擎来实现与后端的数据的交互。
![47156-kvq5z3c5xs.png](http://www.sukidesu.top/usr/uploads/2020/03/4006492100.png)

# 爬虫
使用Python Request 和 bs4 爬取网易云热门歌单的歌曲，使用lxml进行解析

# 定时任务 - APScheduler
定时任务，你会想起 linux 自带的 crontab ，windows 自带的任务计划，都可以实现守时任务。没错，操作系统基本都会提供定时任务的实现，但是如果你想要更加精细化的控制，或者说任务程序需要跨平台运行，最好还是自己实现定时任务框架，Python 的 apscheduler 提供了非常丰富而且方便易用的定时任务接口。
在这里，我们使用定时任务来实现
- 读取mysql的用户点击信息，写入hdfs，用于后续运算
- 调用livy接口，提交jar包，训练als算法
- 调用爬虫，定期爬取歌曲
- 调用DeepCF的脚本，训练模型

#Gunicorn
Gunicorn是一个unix上被广泛使用的高性能的Python WSGI UNIX HTTP Server。

Nginx是一个轻量级、高性能、稳定性高、并发性好的HTTP和反向代理服务器。也是由于其的特性，其应用非常广。
Nginx主要进行反向代理和负载均衡

#DeepCF
 ![68024-abzj2x268m.png](http://www.sukidesu.top/usr/uploads/2020/03/1340872793.png)
我们把user_rating 和 item_rating输入到两个模型中。
DMF:
user_rating item_rating分别输入到多层感知器中，最后经过(逐元素间的)乘积得到dmf_vector
MLP:
user_rating item_rating 先经过拼接，然后输入到多层感知器中，获得mlp_vector

最后将上述两个vector进行拼接，经过全连接层，输出得分。

要介绍DeepCF算法就要先介绍NeuCF算法：
针对矩阵分解算法，最后通过内积聚合来得到算分的方式，NeuCF的作者认为User和Item的隐向量是相互独立的并且最后是等权重求和，因此他可以使用线性模型来表示，这样支持继续使用神经网络模型来进行加工，所以作者提出了基于神经网络的协同过滤（Neural Collaborative Filtering），就是在隐向量上架MLP层和其他的聚合算子，其中隐向量是通过DL模型自己训练出来的.而DeepCF算法的作者就是在GMF层前面加了多层MLP。

优化器使用的是 随机梯度下降
损失函数是 binary_crossentropy 二进制交叉熵

# als算法
我们的与处理时，首先统计每个用户的听歌总数，将每个歌曲的点击数加一后取对数，*点击数/听歌总数 作为rating，输入到模型中，然后将模型算出的结果写入mysql中。

    // 统计用户的听歌总数
    val user_music_total = df.select($"user_id",$"music_id")
      .groupBy($"user_id").count
      .withColumnRenamed("count","total")
    // 点击数*10 再取对数,再用听过的歌做占比,占比使用上面的总数左连接相除求出
    val music_ratings = df.groupBy($"user_id",$"music_id").count          // groupBy统计用户对每首歌的点击
      .join(user_music_total, Seq("user_id"), "left") // 统计频数，左连接总数
      .withColumn("rating",log($"count"+1)* $"count" / $"total") // 计算得分
      .drop("count","total")// 丢弃中间变量




