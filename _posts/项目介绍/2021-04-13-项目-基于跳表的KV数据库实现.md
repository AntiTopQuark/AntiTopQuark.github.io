---
layout: post
cid: 55
title: 项目-基于跳表的KV数据库实现
slug: 55
date: 2021/04/13 17:46:47
updated: 2021/04/13 17:46:47
status: publish
author: AntiTopQuark
categories: 
  - 项目介绍
tags: 
  - 查询
  - map
  - 数据
  - 操作
  - 过程
  - 表
  - 锁
  - 测试
  - 问题
  - 算法
  - 插入
  - 写者
  - 删除
  - 平衡
customSummary: 
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---



# share_mutex
shared_mutex来解决读者-写者问题，也就是读写锁，和普通锁不一样，读写锁同时只能有一个写者或多个读者，但不能同时既有读者又有写者，读写锁的性能一般比普通锁要好
# 测试
数据	kvdb	map	
10W	1.02s	0.33s	
# 跳表简介

跳表是redis的一个核心组件，也同时被广泛地运用到了各种缓存地实现当中，它的主要优点，就是可以跟红黑树、AVL等平衡树一样，做到比较稳定地插入、查询与删除。理论插入查询删除的算法时间复杂度为O(logN)。
![12224-xbpdnzu6xia.png](http://www.sukidesu.top/usr/uploads/2020/03/1832999944.png)
跳表相对于红黑树，主要有这几个优点：
1. 代码相对简单
2. 如果我们要查询一个区间里面的值，用平衡树可能会麻烦。这里的麻烦指的是实现和理解上，平衡二叉树查询一段区间也是可以做到的。
3.删除一段区间，这个如果是平衡二叉树，就会相当困难，毕竟设计到树的平衡问题，而跳表则没有这种烦恼。好了，相信你对跳表已经有一些认识了，我们来简单介绍平衡二叉树的几个基本操作。

# 查询

假如我们要查询11，那么我们从最上层出发，发现下一个是5，再下一个是13，已经大于11，所以进入下一层，下一层的一个是9，查找下一个，下一个又是13，再次进入下一层。最终找到11。
![03019-kiviynrh65.png](http://www.sukidesu.top/usr/uploads/2020/03/282921327.png)

是不是非常的简单？我们可以把查找的过程总结为一条二元表达式（下一个是否大于结果？下一个：下一层）。理解跳表的查询过程非常重要，试试看查询其他数字，只要你理解了查询，后面两种都非常简单。

# 插入

插入的时候，首先要进行查询，然后从最底层开始，插入被插入的元素。然后看看从下而上，是否需要逐层插入。可是到底要不要插入上一层呢？我们都知道，我们想每层的跳跃都非常高效，越是平衡就越好（第一层1级跳，第二层2级跳，第3层4级跳，第4层8级跳）。但是用算法实现起来，确实非常地复杂的，并且要严格地按照2地指数次幂，我们还要对原有地结构进行调整。所以跳表的思路是抛硬币，听天由命，产生一个随机数，50%概率再向上扩展，否则就结束。这样子，每一个元素能够有X层的概率为0.5^(X-1)次方。反过来，第X层有多少个元素的数学期望大家也可以算一下。

# 删除

同插入一样，删除也是先查找，查找到了之后，再从下往上逐个删除。比较简单，就不再赘叙。

