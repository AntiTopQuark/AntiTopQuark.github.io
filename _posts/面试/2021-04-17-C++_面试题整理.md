---
layout: post
cid: 99
title: C++ 面试题整理
slug: 99
date: 2021/04/17 21:47:00
updated: 2021/04/19 11:18:02
status: publish
author: AntiTopQuark
categories: 
  - 面试
tags: 
  - value
  - 类型
  - 函数
  - 变量
  - 程序
  - int
  - 方法
  - 编译
  - second
  - 内存
  - 系统
  - 存储
  - 用户
  - 错误
  - 对象
  - 文件
  - 数据
  - 操作
  - class
  - p
  - 参数
  - 试题
  - 字符
  - struct
  - return
  - 开发
  - 程序员
  - 处理
  - 转换
  - 特征
  - 步骤
  - 知乎
  - static
  - public
  - const
  - 内联
  - 指针
customSummary: 
noThumbInfoStyle: default
outdatedNotice: no
reprint: standard
thumb: 
thumbChoice: default
thumbDesc: 
thumbSmall: 
thumbStyle: default
---


[TOC]

### 1. C++和C的区别

1. C是面向过程的语言，是一个结构化的语言，考虑如何通过一个过程对输入进行处理得到输出；C++是面向对象的语言，主要特征是“封装、继承和多态”。
   封装隐藏了实现细节，使得代码模块化；
   派生类可以继承父类的数据和方法，扩展了已经存在的模块，实现了代码重用；
   多态则是“一个接口，多种实现”，**通过派生类重写父类的虚函数，**实现了接口的重用。
2. C和C++动态管理内存的方法不一样，C是使用malloc/free，而C++除此之外还有new/delete关键字。
3. C++支持函数重载，C不支持函数重载
   函数重载：C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同
4. C++中有引用，C中不存在引用的概念

### 2. C++中指针与引用的区别

1. 指针是一个新的变量，存储了另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；
   引用只是一个别名，还是变量本身，对引用的任何操作就是对变量本身进行操作，以达到修改变量的目的
2. 引用只有一级，而指针可以有多级
3. 指针传参的时候，还是值传递，指针本身的值不可以修改，需要通过解引用才能对指向的对象进行操作
   引用传参的时候，传进来的就是变量本身，因此变量可以被修改

### 3. C++ 内存管理

在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

- 栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。　　
- 堆：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
- 自由存储区：就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。
- 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。
- 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

![img](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/image-20210418135731700.png)

#### C++ 堆和栈的区别

1.       管理方式不同:
         栈，由编译器自动管理，无需程序员手工控制；堆：产生和释放由程序员控制。

2.       空间大小不同：
         栈的空间有限；堆内存可以达到4G，。

3.       能否产生碎片不同：
         栈不会产生碎片，因为栈是种先进后出的队列。堆则容易产生碎片，多次的new/delete会造成内存的不连续，从而造成大量的碎片。

4.       生长方向不同：
         堆的生长方式是向上的，栈是向下的。

5.       分配方式不同：
         堆是动态分配的。栈可以是静态分配和动态分配两种，但是栈的动态分配由编译器释放。

6.       分配效率不同：
         栈是机器系统提供的数据结构，计算机底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令。堆则是由C/C++函数库提供，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。

- 堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家  尽量用栈，而不是用堆。
- 栈和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。
- 无论是堆还是栈，都要防止越界现象的发生。

#### C++ 字节对齐

##### 字节对齐的原因

1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
2）硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升,帮助cpu寻址。

【注意】（对齐位数跟处理器位数和编译器都有关）VS, VC等编译器默认是#pragma pack(8)，所以测试我们的规则会正常；注意gcc默认是#pragma pack(4)，并且gcc只支持1,2,4对齐。

##### 对齐规则

每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫**对齐单位**。

(1) 结构体第一个成员的**偏移量（offset）**为0，以后每个成员相对于结构体首地址的 offset 都是**该成员大小与有效对齐值中较小那个**的整数倍，如有需要编译器会在成员之间加上填充字节。

(2) **结构体的总大小**为 有效对齐值 的**整数倍**，如有需要编译器会在最末一个成员之后加上填充字节。

```C++
//32位系统
#pragma pack(4)
#include<stdio.h>
struct
{
    int i;    
    char c1;  
    char c2;  
}x1;

struct{
    char c1;  
    int i;    
    char c2;  
}x2;

struct{
    char c1;  
    char c2; 
    int i;    
}x3;

int main()
{
    printf("%d\n",sizeof(x1));  // 输出8
    printf("%d\n",sizeof(x2));  // 输出12
    printf("%d\n",sizeof(x3));  // 输出8
    return 0;
}
```

![img](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/v2-86c644ce29b1e2d3858380aaa631cc1d_720w.jpg)

如果前面加上#pragma pack(1)，那么此时有效对齐值为1字节，此时根据对齐规则，不难看出成员是连续存放的，三个结构体的大小都是6字节。

![img](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/v2-672ebe0ccc1430adbda00dfd7abc0375_720w.jpg)

如果前面加上#pragma pack(2)，有效对齐值为2字节，此时根据对齐规则，三个结构体的大小应为6,8,6。内存分布图如下：

![img](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/v2-1c35bc20c76d85d07855901964488637_720w.jpg)

#### 描述内存分配方式以及它们的区别?

1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。

3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。

### 4. new与malloc的10点区别

1. 申请的内存所在位置
   new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。
   自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。特别的，new甚至可以不为对象分配内存

2. 返回类型安全性：
   new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

3. 内存分配失败时的返回值
   new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。

4. 是否需要指定内存大小
   使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

5. 是否调用构造函数/析构函数
   使用new操作符来分配对象内存时会经历三个步骤：

   - 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
   - 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
   - 第三部：对象构造完成后，返回一个指向该对象的指针。

   使用delete操作符来释放对象内存时会经历两个步骤：

   - 第一步：调用对象的析构函数。
   - 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。

   总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。

6. 对数组的处理
   C++提供了new[]与delete[]来专门处理数组类型:

   ```C++
   A * ptr = new A[10];//分配10个A对象
   ```

   使用new[]分配的内存必须使用delete[]进行释放：

   ```C++
   delete [] ptr;
   ```

   new对数组的支持体现在**它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。**

   至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：

   ```C++
   int * ptr = (int *) malloc( sizeof(int) );//分配一个10个int元素的数组
   ```

7. new与malloc是否可以相互调用
   operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。
8. 是否可以被重载
   opeartor new /operator delete可以被重载。而malloc/free并不允许重载。
9. 能够直观地重新分配内存
   使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。
   new没有这样直观的配套设施来扩充内存。
10. 客户处理内存分配不足
    在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型,指向了一个没有参数没有返回值的函数,即为错误处理函数。
    对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。

|        特征        |              new/delete               |             malloc/free              |
| :----------------: | :-----------------------------------: | :----------------------------------: |
|   分配内存的位置   |              自由存储区               |                  堆                  |
| 内存分配失败返回值 |             完整类型指针              |                void*                 |
| 内存分配失败返回值 |             默认抛出异常              |               返回NULL               |
|   分配内存的大小   |       由编译器根据类型计算得出        |          必须显式指定字节数          |
|      处理数组      |       有处理数组的new版本new[]        | 需要用户计算数组的大小后进行内存分配 |
|  已分配内存的扩充  |            无法直观地处理             |         使用realloc简单完成          |
|    是否相互调用    | 可以，看具体的operator new/delete实现 |             不可调用new              |
| 分配内存时内存不足 | 客户能够指定处理函数或重新制定分配器  |       无法通过用户代码进行处理       |
|      函数重载      |                 允许                  |                不允许                |
| 构造函数与析构函数 |                 调用                  |                不调用                |

### 5. delete和delete[]的区别

delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数

用new分配的内存用delete释放，用new[]分配的内存用delete[]释放

### 6. new、delete、malloc、free关系

malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。

对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。

因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。

delete会调用对象的析构函数,和delete对应free只会释放内存，new调用构造函数。

### 7. STL库用过吗？常见的STL容器有哪些？算法用过几个？

STL包括两部分内容：容器和算法

容器即存放数据的地方，比如array, vector，分为两类，序列式容器和关联式容器

序列式容器，其中的元素不一定有序，但是都可以被排序，比如vector,list,queue,stack，heap, priority-queue, slist

关联式容器，内部结构是一个平衡二叉树，每个元素都有一个键值和一个实值，比如map, set, hashtable, hash_set

算法有排序，复制等，以及各个容器特定的算法

迭代器是STL的精髓，迭代器提供了一种方法，使得它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构，它将容器和算法分开，让二者独立设计。

#### STL 容器

| 容器                                                         | 底层数据结构      | 时间复杂度                                                | 有无序 | 可不可重复 | 其他                                                         |
| ------------------------------------------------------------ | ----------------- | --------------------------------------------------------- | ------ | ---------- | ------------------------------------------------------------ |
| [array](https://github.com/huihut/interview/tree/master/STL#array) | 数组              | 随机读改 O(1)                                             | 无序   | 可重复     | 支持随机访问                                                 |
| [vector](https://github.com/huihut/interview/tree/master/STL#vector) | 数组              | 随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) | 无序   | 可重复     | 支持随机访问                                                 |
| [deque](https://github.com/huihut/interview/tree/master/STL#deque) | 双端队列          | 头尾插入、头尾删除 O(1)                                   | 无序   | 可重复     | 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问  |
| [forward_list](https://github.com/huihut/interview/tree/master/STL#forward_list) | 单向链表          | 插入、删除 O(1)                                           | 无序   | 可重复     | 不支持随机访问                                               |
| [list](https://github.com/huihut/interview/tree/master/STL#list) | 双向链表          | 插入、删除 O(1)                                           | 无序   | 可重复     | 不支持随机访问                                               |
| [stack](https://github.com/huihut/interview/tree/master/STL#stack) | deque / list      | 顶部插入、顶部删除 O(1)                                   | 无序   | 可重复     | deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 |
| [queue](https://github.com/huihut/interview/tree/master/STL#queue) | deque / list      | 尾部插入、头部删除 O(1)                                   | 无序   | 可重复     | deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时 |
| [priority_queue](https://github.com/huihut/interview/tree/master/STL#priority_queue) | vector + max-heap | 插入、删除 O(log2n)                                       | 有序   | 可重复     | vector容器+heap处理规则                                      |
| [set](https://github.com/huihut/interview/tree/master/STL#set) | 红黑树            | 插入、删除、查找 O(log2n)                                 | 有序   | 不可重复   |                                                              |
| [multiset](https://github.com/huihut/interview/tree/master/STL#multiset) | 红黑树            | 插入、删除、查找 O(log2n)                                 | 有序   | 可重复     |                                                              |
| [map](https://github.com/huihut/interview/tree/master/STL#map) | 红黑树            | 插入、删除、查找 O(log2n)                                 | 有序   | 不可重复   |                                                              |
| [multimap](https://github.com/huihut/interview/tree/master/STL#multimap) | 红黑树            | 插入、删除、查找 O(log2n)                                 | 有序   | 可重复     |                                                              |
| [unordered_set](https://github.com/huihut/interview/tree/master/STL#unordered_set) | 哈希表            | 插入、删除、查找 O(1) 最差 O(n)                           | 无序   | 不可重复   |                                                              |
| [unordered_multiset](https://github.com/huihut/interview/tree/master/STL#unordered_multiset) | 哈希表            | 插入、删除、查找 O(1) 最差 O(n)                           | 无序   | 可重复     |                                                              |
| [unordered_map](https://github.com/huihut/interview/tree/master/STL#unordered_map) | 哈希表            | 插入、删除、查找 O(1) 最差 O(n)                           | 无序   | 不可重复   |                                                              |
| [unordered_multimap](https://github.com/huihut/interview/tree/master/STL#unordered_multimap) | 哈希表            | 插入、删除、查找 O(1) 最差 O(n)                           | 无序   | 可重复     |                                                              |

#### STL 算法

| 算法                                                         | 底层算法                                            | 时间复杂度 | 可不可重复 |
| ------------------------------------------------------------ | --------------------------------------------------- | ---------- | ---------- |
| [find](http://www.cplusplus.com/reference/algorithm/find/)   | 顺序查找                                            | O(n)       | 可重复     |
| [sort](https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/include/bits/stl_algo.h#L4808) | [内省排序](https://en.wikipedia.org/wiki/Introsort) | O(n*log2n) | 可重复     |

### 8. const知道吗？解释一下其作用

const修饰类的成员变量，表示常量不可能被修改

const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数;

#### 作用

1. 修饰变量，说明该变量不可以被改变；
2. 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；
3. 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；
4. 修饰成员函数，说明该成员函数内不能修改成员变量。

#### const 的指针与引用

- 指针

  - 指向常量的指针（pointer to const）
    `const int* pOne;  //指向整形常量的指针，它指向的值不能修改`
  - 自身是常量的指针（常量指针，const pointer）
    `int * const pTwo;  //指向整形的常量指针，它不能在指向别的变量，但指向（变量）的值可以修改。 `

- 引用

  - 指向常量的引用（reference to const）

    ```C++
    int i = 42;  
    const int &r1 = i;       //正确：允许将const int & 绑定到一个普通int对象上  
    const int &r2 = 42;      //正确  
    const int &r3 = r1 * 2;  //正确  
    int &r4 = r1 * 2;        //错误  
    ```

  - 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰

```C++
// 类
class A {
private:
    const int a;                // 常对象成员，可以使用初始化列表或者类内初始化
public:
    // 构造函数
    A() : a(0) {};
    A(int x) : a(x) {};        // 初始化列表
    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常成员函数，不得修改类中的任何数据成员的值
};

void function() {
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数
    const A a;                  // 常对象，只能调用常成员函数
    const A *p = &a;            // 指针变量，指向常对象
    const A &q = a;             // 指向常对象的引用

    // 指针
    char greeting[] = "Hello";
    char *p1 = greeting;                // 指针变量，指向字符数组变量
    const char *p2 = greeting;          // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
    char *const p3 = greeting;          // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
    const char *const p4 = greeting;    // 自身是常量的指针，指向字符数组常量
}

// 函数
void function1(const int Var);           // 传递过来的参数在函数内不可变
void function2(const char *Var);         // 参数指针所指内容为常量
void function3(char *const Var);         // 参数指针为常量
void function4(const int &Var);          // 引用参数在函数内为常量

// 函数返回值
const int function5();      // 返回一个常数
const int *function6();     // 返回一个指向常量的指针变量，使用：const int *p = function6();
int *const function7();     // 返回一个指向变量的常指针，使用：int* const p = function7();
```

### 9. static

作用:

1. 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。
2. 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。
3. 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。
4. 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。

1）函数体内： static 修饰的局部变量作用范围为该函数体，不同于auto变量，其内存只被分配一次，因此其值在下次调用的时候维持了上次的值

2）模块内：static修饰全局变量或全局函数，可以被模块内的所有函数访问，但是不能被模块外的其他函数访问，使用范围限制在声明它的模块内

3）类中：修饰成员变量，表示该变量属于整个类所有，对类的所有对象只有一份拷贝

4）类中：修饰成员函数，表示该函数属于整个类所有，不接受this指针，只能访问类中的static成员变量

**注意和const的区别！！！const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象**

### 10. 虚函数时怎么实现的？

每一个含有虚函数的类都至少有有一个与之对应的虚函数表，其中存放着该类所有虚函数对应的函数指针（地址），

类的实例对象不包含虚函数表，只有虚指针；

派生类会生成一个兼容基类的虚函数表。

#### 1. 概述

简单地说，每一个含有虚函数（无论是其本身的，还是继承而来的）的类都至少有一个与之对应的虚函数表，其中存放着该类所有的虚函数对应的函数指针。例：

![img](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/898333-20160609210402699-1501495771.png)
其中：

- B的虚函数表中存放着B::foo和B::bar两个函数指针。
- D的虚函数表中存放的既有继承自B的虚函数B::foo，又有重写（override）了基类虚函数B::bar的D::bar，还有新增的虚函数D::quz。

*提示：为了描述方便，本文在探讨对象内存布局时，将忽略内存对齐对布局的影响。*

#### 2. 虚函数表构造过程

从编译器的角度来说，B的虚函数表很好构造，D的虚函数表构造过程相对复杂。下面给出了构造D的虚函数表的一种方式（仅供参考）：
![img](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/898333-20160609210418246-1188626035.png)

*提示：该过程是由编译器完成的，因此也可以说：虚函数替换过程发生在编译时。*

#### 3. 虚函数调用过程

以下面的程序为例：
![img](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/898333-20160609210434386-1391536209.png)

编译器只知道pb是B*类型的指针，并不知道它指向的具体对象类型 ：pb可能指向的是B的对象，也可能指向的是D的对象。

但对于“pb->bar()”，编译时能够确定的是：此处operator->的另一个参数是B::bar（因为pb是B*类型的，编译器认为bar是B::bar），而B::bar和D::bar在各自虚函数表中的偏移位置是相等的。

无论pb指向哪种类型的对象，只要能够确定被调函数在虚函数中的偏移值，待运行时，能够确定具体类型，并能找到相应vptr了，就能找出真正应该调用的函数。

*提示：本人曾在“[C/C++杂记：深入理解数据成员指针、函数成员指针](http://www.cnblogs.com/malecrab/p/5572119.html)”一文中提到：虚函数指针中的ptr部分为虚函数表中的偏移值（以字节为单位）加1。*

B::bar是一个虚函数指针， 它的ptr部分内容为9，它在B的虚函数表中的偏移值为8（8+1=9）。

当程序执行到“pb->bar()”时，已经能够判断pb指向的具体类型了：

- 如果pb指向B的对象，可以获取到B对象的vptr，加上偏移值8（(char*)vptr + 8），可以找到B::bar。
- 如果pb指向D的对象，可以获取到D对象的vptr，加上偏移值8（(char*)vptr + 8） ，可以找到D::bar。
- 如果pb指向其它类型对象...同理...

#### 4. 多重继承

当一个类继承多个类，且多个基类都有虚函数时，子类对象中将包含多个虚函数表的指针（即多个vptr），例：
![img](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/898333-20160609210449511-346261020.png)

其中：D自身的虚函数与B基类共用了同一个虚函数表，因此也称B为D的主基类（primary base class）。

虚函数替换过程与前面描述类似，只是多了一个虚函数表，多了一次拷贝和替换的过程。

虚函数的调用过程，与前面描述基本类似，区别在于基类指针指向的位置可能不是派生类对象的起始位置，以如下面的程序为例：
![img](https://image-bed113224.oss-cn-beijing.aliyuncs.com/img/898333-20160609210505761-312956336.png)

### 11. STL中map和set的原理（关联式容器）——红黑树

map和set的底层实现主要通过红黑树来实现

红黑树是一种特殊的二叉查找树

1）每个节点或者是黑色，或者是红色 

2）根节点是黑色

3） 每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]

4）如果一个节点是红色的，则它的子节点必须是黑色的

5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

特性4）5）决定了没有一条路径会比其他路径长出2倍，因此红黑树是接近平衡的二叉树。

### 12. `#include <file.h>` 和 `#include "file.h"` 的区别

　　前者是从标准库路径寻找
　　后者是从当前工作路径

### 13. 什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？

动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。

方法：malloc/free要配套，对指针赋值的时候应该注意被赋值的指针是否需要释放；使用的时候记得指针的长度，防止越界

### 14.定义和声明的区别

声明是告诉编译器变量的类型和名字，不会为变量分配空间

定义需要分配空间，同一个变量可以被声明多次，但是只能被定义一次

### 15.C++文件编译与执行的四个阶段

1）预处理：根据文件中的预处理指令来修改源文件的内容

2）编译：编译成汇编代码

3）汇编：把汇编代码翻译成目标机器指令

4）链接：链接目标代码生成可执行程序

### 16. STL中的vector的实现，是怎么扩容的？

vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。 
vector就是一个动态增长的数组，里面有一个指针指向一片连续的空间，当空间装不下的时候，会申请一片更大的空间，将原来的数据拷贝过去，并释放原来的旧空间。当删除的时候空间并不会被释放，只是清空了里面的数据。对比array是静态空间一旦配置了就不能改变大小。

**vector的动态增加大小的时候，并不是在原有的空间上持续新的空间（无法保证原空间的后面还有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，并释放原空间。在VS下是1.5倍扩容，在GCC下是2倍扩容。**

在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的

### 17. STL中unordered_map和map的区别

map是STL中的一个关联容器，提供键值对的数据管理。底层通过红黑树来实现，实际上是二叉排序树和非严格意义上的二叉平衡树。所以在map内部所有的数据都是有序的，且map的查询、插入、删除操作的时间复杂度都是O(logN)。

unordered_map和map类似，都是存储key-value对，可以通过key快速索引到value，不同的是unordered_map不会根据key进行排序。unordered_map底层是一个防冗余的哈希表，存储时根据key的hash值判断元素是否相同，即unoredered_map内部是无序的。

### 18. 构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因 ？

1、构造函数不能声明为虚函数

- 1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等

- 2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了

2、析构函数最好声明为虚函数

首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。

**如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。**

### 19. 静态绑定和动态绑定的介绍

静态绑定和动态绑定是C++多态性的一种特性

1）对象的静态类型和动态类型

静态类型：对象在声明时采用的类型，在编译时确定

动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改

2）静态绑定和动态绑定

静态绑定：绑定的是对象的静态类型，函数依赖于对象的静态类型，在编译期确定

动态绑定：绑定的是对象的动态类型，函数依赖于对象的动态类型，在运行期确定

**只有虚函数才使用的是动态绑定，其他的全部是静态绑定**

### 20. **引用是否能实现动态绑定，为什么引用可以实现**

可以。因为引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指的对象的实际类型所定义的。

### 21. **深拷贝和浅拷贝的区别**

深拷贝和浅拷贝可以简单的理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，如果资源重新分配了就是深拷贝；反之没有重新分配资源，就是浅拷贝。

### 22 .什么情况下会调用拷贝构造函数（三种情况） 

系统自动生成的构造函数：普通构造函数和拷贝构造函数 （在没有定义对应的构造函数的时候）

生成一个实例化的对象会调用一次普通构造函数，而用一个对象去实例化一个新的对象所调用的就是拷贝构造函数

调用拷贝构造函数的情形：

1）用类的一个对象去初始化另一个对象的时候

2）当函数的参数是类的对象时，就是值传递的时候，如果是引用传递则不会调用

3）当函数的返回值是类的对象或者引用的时候

```C++
#include <iostream>
#include <string>
 
using namespace std;
 
class A{
	private:
		int data;
	public:
		A(int i){ data = i;} 	//自定义的构造函数
		A(A && a);  			//拷贝构造函数 
		int getdata(){return data;} 
};
//拷贝构造函数 
A::A(A && a){
	data = a.data;
	cout <<"拷贝构造函数执行完毕"<<endl;
}
//参数是对象，值传递，调用拷贝构造函数
int getdata1(A a){
	return a.getdata();
}
//参数是引用，引用传递，不调用拷贝构造函数 
int getdata2(A &a){
	return a.getdata();
} 
//返回值是对象类型，会调用拷贝构造函数
 A getA1(){
 	A a(0);
 	return a;
 } 
 //返回值是引用类型，会调用拷贝构造函数，因为函数体内生成的对象是临时的，离开函数就消失
 A& getA2(){
 	A a(0);
 	return a;
 } 
 
 int main(){
    A a1(1);  
    A b1(a1);           		//用a1初始化b1，调用拷贝构造函数  
    A c1=a1;            		//用a1初始化c1，调用拷贝构造函数  
  
    int i=getdata1(a1);        	//函数形参是类的对象，调用拷贝构造函数  
    int j=getdata2(a1);      	//函数形参类型是引用，不调用拷贝构造函数  
  
    A d1=getA1();       		//调用拷贝构造函数  
    A e1=getA2();     			//调用拷贝构造函数  
  
    return 0;  
} 
```

### 23.C++的四种强制转换 

类型转化机制可以分为隐式类型转换和显示类型转化（强制类型转换）

(new-type) expression
new-type (expression)
隐式类型转换比较常见，在混合类型表达式中经常发生；四种强制类型转换操作符：

static_cast、dynamic_cast、const_cast、reinterpret_cast

1）static_cast ：编译时期的静态类型检查

static_cast < type-id > ( expression )

该运算符把expression转换成type-id类型，在编译时使用类型信息执行转换，在转换时执行必要的检测（指针越界、类型检查），其操作数相对是安全的

2）dynamic_cast：运行时的检查

用于在集成体系中进行安全的向下转换downcast，即基类指针/引用->派生类指针/引用

dynamic_cast是4个转换中唯一的RTTI操作符，提供运行时类型检查。

dynamic_cast如果不能转换返回NULL

源类中必须要有虚函数，保证多态，才能使用dynamic_cast<source>(expression)

3）const_cast

去除const常量属性，使其可以修改 ; volatile属性的转换

4）reinterpret_cast

通常为了将一种数据类型转换成另一种数据类型

### 24. **调试程序的方法** 

windows下直接使用vs的debug功能

linux下直接使用gdb，我们可以在其过程中给程序添加断点，监视等辅助手段，监控其行为是否与我们设计相符

### 25.extern“C”作用

extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。

```C++
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```

### 26.typdef和define区别

**#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查**

**typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名**
```C++
typedef    (int*)      pINT;
#define    pINT2   int*
```
效果相同？实则不同！实践中见差别：pINT a,b;的效果同int *a; int *b;表示定义了两个整型指针变量。而pINT2 a,b;的效果同int *a, b;表示定义了一个整型指针变量a和整型变量b。

### 27. volatile关键字在程序设计中有什么作用

volatile是“易变的”、“不稳定”的意思。volatile是C的一个较为少用的关键字，它用来解决变量在“共享”环境下容易出现读取错误的问题。

```C++
volatile int i = 10; 
```

- volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。
- volatile 关键字声明的变量，**每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）**
- const 可以是 volatile （如只读的状态寄存器）
- 指针可以是 volatile

### 28. 引用作为函数参数以及返回值的好处

对比值传递，引用传参的好处：

1）在函数内部可以对此参数进行修改

2）提高函数调用和运行的效率（所以没有了传值和生成副本的时间和空间消耗）

如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。

用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。

但是有以下的限制：

1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁

2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak

3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。 

### 29. **纯虚函数**

纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承

包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象

普通函数是静态编译的，没有运行时多态

```C++
virtual int A() = 0;
```

#### 虚函数、纯虚函数

- 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
- 虚函数在子类里面可以不重写；但**纯虚函数必须在子类实现才可以实例化子类**。
- 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
- **带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用**。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
- 虚基类是虚继承中的基类，具体见下文虚继承。

### 30. 虚继承

#### 虚继承

虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。

底层实现原理与编译器相关，一般通过**虚基类指针**和**虚基类表**实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。

实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。



虚拟继承是多重继承中特有的概念，

类D继承自类B1，B2，而类B1，B2都继承自类A，

当类A为非虚基类，即类B1，B2非虚继承类A时，继承关系如下图：

A      A

↓       ↓

B1     B2

 ↘  D  ↙

代码如下：

```C++
1 class A{};
2 class B1 : public A{};
3 class B2 : public A{};
4 class D : public B1, public B2{};
```

 

因此，为了节省内存空间，可以将类A定义为虚基类，即类B1，B2虚继承类A，继承关系如下：

​    A

 ↙    ↘

B1     B2

 ↘  D  ↙

代码如下：

```C++
1 class A{};
2 class B1 : virtual public A{};
3 class B2 : virtual public A{};
4 class D : public B1, public B2{};
```

### 31. 什么是野指针

野指针不是NULL指针，是未初始化或者未清零的指针，它指向的内存地址不是程序员所期望的，可能指向了受限的内存

成因：

1）指针变量没有被初始化

2）指针指向的内存被释放了，但是指针没有置NULL 

3）指针超过了变量了的作用范围，比如b[10]，指针b+11

### 32. 线程安全和线程不安全

线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可以使用，不会出现数据不一致或者数据污染。

线程不安全就是不提供数据访问保护，有可能多个线程先后更改数据所得到的数据就是脏数据。

### 33. C++中内存泄漏的几种情况

内存泄漏是指己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

1）类的构造函数和析构函数中new和delete没有配套

2）在释放对象数组时没有使用delete[]，使用了delete

3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露

4）没有正确的清楚嵌套的对象指针

### 34. 栈溢出的原因以及解决方法

1）函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈

2）局部变量体积太大。

解决办法大致说来也有两种：

1> 增加栈内存的数目；增加栈内存方法如下,在vc6种依次选择Project->Setting->Link,在Category中选择output,在Reserve中输入16进制的栈内存大小如:0x10000000

2> 使用堆内存；具体实现由很多种方法可以直接把数组定义改成指针,然后动态申请内存;也可以把局部变量变成全局变量,一个偷懒的办法是直接在定义前边加个static,呵呵,直接变成静态变量(实质就是全局变量)

### 35. C++标准库vector以及迭代器

每种容器类型都定义了自己的迭代器类型，每种容器都定义了一队命名为begin和end的函数，用于返回迭代器。

迭代器是容器的精髓，它提供了一种方法使得它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构，它将容器和算法分开，让二者独立设计。

### 36. C++ 11有哪些新特性

C++11不仅包含核心语言的新机能，而且扩展了C++的标准程序库（STL），并入了大部分的C++ Technical Report 1（TR1）程序库。C++11包括大量的新特性：包括lambda表达式，类型推导关键字auto、decltype，和模板的大量改进。

auto

C++11中引入auto第一种作用是为了自动类型推导

auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作

decltype

decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型，有实例如下：

nullptr

nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，

lambda表达式类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：

> \[函数对象参数](操作符重载函数参数)mutable
>     或
> exception声明->返回值类型{函数体}

### 37. C++中vector和list的区别

vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。

list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。

vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector<int>::iterator支持“+”，“+=”，“<”等操作符。

list的内存空间可以是不连续，它不支持随机访问，因此list<int>::iterator则不支持“+”、“+=”、“<”等

vector<int>::iterator和list<int>::iterator都重载了“++”运算符。

总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;
如果需要大量的插入和删除，而不关心随机存取，则应使用list。

### 38. C语言的函数调用过程

函数的调用过程：

1）从栈空间分配存储空间

2）从实参的存储空间复制值到形参栈空间

3）进行运算

形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。

数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。

当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。

传值：传值，实际是把实参的值赋值给行参，相当于copy。那么对行参的修改，不会影响实参的值 。
传址： 实际是传值的一种特殊方式，只是他传递的是地址，不是普通的赋值，那么传地址以后，实参和行参都指向同一个对象，因此对形参的修改会影响到实参。

### 39. C++中的基本数据类型及派生类型

1）整型 int

2）浮点型  单精度float，双精度double

3）字符型 char

4）逻辑型 bool

5）控制型 void

基本类型的字长及其取值范围可以放大和缩小，改变后的类型就叫做基本类型的派生类型。派生类型声明符由基本类型关键字char、int、float、double前面加上类型修饰符组成。

 类型修饰符包括：

>short     短类型，缩短字长

>long      长类型，加长字长

>signed    有符号类型，取值范围包括正负值

>unsigned   无符号类型，取值范围只包括正值

### 40. 友元函数和友元类

友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。

通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。

友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。

**1）友元函数**

有元函数是可以访问类的私有成员的非成员函数。它是定义在类外的普通函数，不属于任何类，但是需要在类的定义中加以声明。

将全局函数声明为友元的写法如下：

`friend  返回值类型  函数名(参数表);`

将其他类的成员函数声明为友元的写法如下：

`friend  返回值类型  其他类的类名::成员函数名(参数表);`

一个函数可以是多个类的友元函数，只需要在各个类中分别声明。

**2）友元类**

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。        

 friend class 类名; 

**使用友元类时注意：** 

(1) 友元关系不能被继承。 
(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。 
(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明

### 41. C++线程中的几种锁机制

线程之间的锁有：互斥锁、条件锁、自旋锁、读写锁、递归锁。一般而言，锁的功能越强大，性能就会越低。

1）互斥锁

互斥锁用于控制多个线程对他们之间共享资源互斥访问的一个信号量。也就是说是为了避免多个线程在某一时刻同时操作一个共享资源。例如线程池中的有多个空闲线程和一个任务队列。任何是一个线程都要使用互斥锁互斥访问任务队列，以避免多个线程同时访问任务队列以发生错乱。

在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以阻塞方式进行等待。

头文件：<pthread.h>

类型：pthread_mutex_t，

函数：pthread_mutex_init(pthread_mutex_t * mutex, const phtread_mutexattr_t * mutexattr);//动态方式创建锁，相当于new动态创建一个对象

            pthread_mutex_destory(pthread_mutex_t *mutex)//释放互斥锁，相当于delete
    
            pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//以静态方式创建锁
    
            pthread_mutex_lock(pthread_mutex_t *mutex)//以阻塞方式运行的。如果之前mutex被加锁了，那么程序会阻塞在这里。
    
            pthread_mutex_unlock(pthread_mutex_t *mutex)
    
            int pthread_mutex_trylock(pthread_mutex_t * mutex);//会尝试对mutex加锁。如果mutex之前已经被锁定，返回非0,；如果mutex没有被锁定，则函数返回并锁定mutex
    
                                                                                                           //该函数是以非阻塞方式运行了。也就是说如果mutex之前已经被锁定，函数会返回非0，程序继续往下执行。

2）条件锁

条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。这个过程中就使用到了条件变量pthread_cond_t。

头文件：<pthread.h>

类型：pthread_cond_t

函数：pthread_cond_init(pthread_cond_t * condtion, const phtread_condattr_t * condattr);//对条件变量进行动态初始化，相当于new创建对象

            pthread_cond_destory(pthread_cond_t * condition);//释放动态申请的条件变量，相当于delete释放对象
    
            pthread_cond_t condition = PTHREAD_COND_INITIALIZER;//静态初始化条件变量
    
            pthread_cond_wait(pthread_cond_t * cond, pthread_mutex_t * mutex);//该函数以阻塞方式执行。如果某个线程中的程序执行了该函数，那么这个线程就会以阻塞方式等待，直到收到pthread_cond_signal或者pthread_cond_broadcast函数发来的信号而被唤醒。

注意：pthread_cond_wait函数的语义相当于：首先解锁互斥锁，然后以阻塞方式等待条件变量的信号，收到信号后又会对互斥锁加锁。

           为了防止“虚假唤醒”，该函数一般放在while循环体中。例如

 

pthread_mutex_lock(mutex);//加互斥锁

while(条件不成立)//当前线程中条件变量不成立

{

pthread_cond_wait(cond, mutex);//解锁，其他线程使条件成立发送信号，加锁。

}

...//对进程之间的共享资源进行操作

pthread_mutex_unlock(mutex);//释放互斥锁

            pthread_cond_signal(pthread_cond_t * cond);//在另外一个线程中改变线程，条件满足发送信号。唤醒一个等待的线程（可能有多个线程处于阻塞状态），唤醒哪个线程由具体的线程调度策略决定
    
            pthread_cond_broadcast(pthread_cond_t * cond);//以广播形式唤醒所有因为该条件变量而阻塞的所有线程，唤醒哪个线程由具体的线程调度策略决定
    
            pthread_cond_timedwait(pthread_cond_t * cond, pthread_mutex_t * mutex, struct timespec * time);//以阻塞方式等待，如果时间time到了条件还没有满足还是会结束

3）自旋锁

前面的两种锁是比较常见的锁，也比较容易理解。下面通过比较互斥锁和自旋锁原理的不同，这对于真正理解自旋锁有很大帮助。

假设我们有一个两个处理器core1和core2计算机，现在在这台计算机上运行的程序中有两个线程：T1和T2分别在处理器core1和core2上运行，两个线程之间共享着一个资源。

首先我们说明互斥锁的工作原理，互斥锁是是一种sleep-waiting的锁。假设线程T1获取互斥锁并且正在core1上运行时，此时线程T2也想要获取互斥锁（pthread_mutex_lock），但是由于T1正在使用互斥锁使得T2被阻塞。当T2处于阻塞状态时，T2被放入到等待队列中去，处理器core2会去处理其他任务而不必一直等待（忙等）。也就是说处理器不会因为线程阻塞而空闲着，它去处理其他事务去了。

而自旋锁就不同了，自旋锁是一种busy-waiting的锁。也就是说，如果T1正在使用自旋锁，而T2也去申请这个自旋锁，此时T2肯定得不到这个自旋锁。与互斥锁相反的是，此时运行T2的处理器core2会一直不断地循环检查锁是否可用（自旋锁请求），直到获取到这个自旋锁为止。

从“自旋锁”的名字也可以看出来，如果一个线程想要获取一个被使用的自旋锁，那么它会一致占用CPU请求这个自旋锁使得CPU不能去做其他的事情，直到获取这个锁为止，这就是“自旋”的含义。

当发生阻塞时，互斥锁可以让CPU去处理其他的任务；而自旋锁让CPU一直不断循环请求获取这个锁。通过两个含义的对比可以我们知道“自旋锁”是比较耗费CPU的

头文件：<linux\spinlock.h>

自旋锁的类型：spinlock_t

相关函数：初始化：spin_lock_init(spinlock_t *x);

             spin_lock(x);   //只有在获得锁的情况下才返回，否则一直“自旋”
             spin_trylock(x);  //如立即获得锁则返回真，否则立即返回假
             释放锁：spin_unlock(x);
    
                 spin_is_locked(x)//　　该宏用于判断自旋锁x是否已经被某执行单元保持（即被锁），如果是，   返回真，否则返回假。

注意：自旋锁适合于短时间的的轻量级的加锁机制。

4）读写锁

说到读写锁我们可以借助于“读者-写者”问题进行理解。首先我们简单说下“读者-写者”问题。

计算机中某些数据被多个进程共享，对数据库的操作有两种：一种是读操作，就是从数据库中读取数据不会修改数据库中内容；另一种就是写操作，写操作会修改数据库中存放的数据。因此可以得到我们允许在数据库上同时执行多个“读”操作，但是某一时刻只能在数据库上有一个“写”操作来更新数据。这就是一个简单的读者-写者模型。



### 42. **求下面函数的返回值（微软）**

```text
int func(x) 
{ 
int countx = 0; 
while(x) 
{ 
countx ++; 
x = x&(x-1); 
} 
return countx; 
} 
```

假定x = 9999。答案：8



思路：将x转化为2进制，看含有的1的个数。

### 43 . **C++是不是类型安全的？**

答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。

### **44. main 函数执行以前，还会执行什么代码？**

全局对象的构造函数会在main 函数之前执行。



### 45  inline 内联函数

#### 特征

- 相当于把内联函数里面的内容写在调用内联函数处；
- 相当于不用执行进入函数的步骤，直接执行函数体；
- 相当于宏，却比宏多了类型检查，真正具有函数特性；
- 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
- 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

#### 使用

inline 使用

```C++
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

#### 编译器对 inline 函数的处理步骤

1. 将 inline 函数体复制到 inline 函数调用点处；
2. 为所用 inline 函数中的局部变量分配内存空间；
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

#### 优缺点

优点

1. 内联函数同宏函数一样将在被调用处进行代码展开，**省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。**
2. 内联函数相比宏函数来说，在代码展开时，**会做安全检查或自动类型转换**（同普通函数），而宏定义则不会。
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

缺点

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，**是否对函数内联，决定权在于编译器。**

#### 虚函数（virtual）可以是内联函数（inline）吗？

> [Are "inline virtual" member functions ever actually "inlined"?](http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html)

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

虚函数内联使用

```c++
#include <iostream>  
using namespace std;
class Base
{
public:
	inline virtual void who()
	{
		cout << "I am Base\n";
	}
	virtual ~Base() {}
};
class Derived : public Base
{
public:
	inline void who()  // 不写inline时隐式内联
	{
		cout << "I am Derived\n";
	}
};

int main()
{
	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
	Base b;
	b.who();

	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
	Base *ptr = new Derived();
	ptr->who();

	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
	delete ptr;
	ptr = nullptr;

	system("pause");
	return 0;
} 
```

### 47.  sizeof()

- sizeof 对数组，得到整个数组所占空间大小。
- sizeof 对指针，得到指针本身所占空间大小。

### 48. struct 和 typedef struct

#### C 中

```C
// c
typedef struct Student {
    int age; 
} S;
```

等价于

```c
// c
struct Student { 
    int age; 
};

typedef struct Student S;
```

此时 `S` 等价于 `struct Student`，但两个标识符名称空间不相同。

另外还可以定义与 `struct Student` 不冲突的 `void Student() {}`。

#### C++ 中

由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。

一、如果在类标识符空间定义了 `struct Student {...};`，使用 `Student me;` 时，编译器将搜索全局标识符表，`Student` 未找到，则在类标识符内搜索。

即表现为可以使用 `Student` 也可以使用 `struct Student`，如下：

```c++
// cpp
struct Student { 
    int age; 
};

void f( Student me );       // 正确，"struct" 关键字可省略
```

二、若定义了与 `Student` 同名函数之后，则 `Student` 只代表函数，不代表结构体，如下：

```C++
typedef struct Student { 
    int age; 
} S;

void Student() {}           // 正确，定义后 "Student" 只代表此函数

//void S() {}               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名

int main() {
    Student(); 
    struct Student me;      // 或者 "S me";
    return 0;
}
```



### 49 C++ 中 struct 和 class

总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。

#### 区别

- 最本质的一个区别就是默认的访问控制
  1. 默认的继承访问权限。struct 是 public 的，class 是 private 的。
  2. struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。

### 50. union 联合

**联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点**：

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的

union 使用

```C++
#include "iostream"

using namespace std;

union UnioTest {
    int i;
    double d;
};


int main() {
    UnioTest u;
    u.i = 10000;
    u.d = 2.2;
    std::cout << u.i << "||"<<u.d << std::endl;
    return 0;
}
```
#### C语言之大小端问题

##### 释义

大端：高位存在低地址，低位存在高地址；
小端：高位存在高地址，低位存在低地址；（intel的x86，ARM普遍都是属于小端）

##### 举例

如果我们将0x12345678写入到以0x0000开始的内存中，则结果为：

                  big-endian            little-endian
      0x0000          0x12                  0x78
      0x0001          0x34                  0x56
      0x0002          0x56                  0x34
      0x0003          0x78                  0x12   
      
      其中：
      0x12345678，0x12就是高位，0x78就是低位；
      0x0000是低地址，0x0003是高地址；

##### 优缺点

大端小端没有谁优谁劣，各自优势便是对方劣势：
小端模式 ：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。
大端模式 ：符号位的判定固定为第一个字节，容易判断正负。

##### 如何用代码判断系统是大端还是小端

```C++
UINT8 checkCPUendian()//返回1，为小端；反之，为大端；
{
    union
    {
        unsigned int  a;
        unsigned char b;
    }c;
    c.a = 1;
    return 1 == c.b;
}
# 大小端转换
#define EndianConvert16(A)   (( ((uint16)(A) & 0xff00) >> 8)  | \
                             (( (uint16)(A) & 0x00ff) << 8))


#define EndianConvert32(A)   ((( (uint32)(A) & 0xff000000) >> 24)  | \
                             ((  (uint32)(A) & 0x00ff0000) >> 8)   | \
                             ((  (uint32)(A) & 0x0000ff00) << 8)   | \
                             ((  (uint32)(A) & 0x000000ff) << 24))
```





### 51 .explicit（显式）关键字

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换，但 [按语境转换](https://zh.cppreference.com/w/cpp/language/implicit_conversion) 除外

explicit 使用

```C++
struct A
{
	A(int) { }
	operator bool() const { return true; }
};

struct B
{
	explicit B(int) {}
	explicit operator bool() const { return true; }
};

void doA(A a) {}

void doB(B b) {}

int main()
{
	A a1(1);		// OK：直接初始化
	A a2 = 1;		// OK：复制初始化
	A a3{ 1 };		// OK：直接列表初始化
	A a4 = { 1 };		// OK：复制列表初始化
	A a5 = (A)1;		// OK：允许 static_cast 的显式转换 
	doA(1);			// OK：允许从 int 到 A 的隐式转换
	if (a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a6(a1);		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a7 = a1;		// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
	bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化

	B b1(1);		// OK：直接初始化
	B b2 = 1;		// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
	B b3{ 1 };		// OK：直接列表初始化
	B b4 = { 1 };		// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
	B b5 = (B)1;		// OK：允许 static_cast 的显式转换
	doB(1);			// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
	if (b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b6(b1);		// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
	bool b7 = b1;		// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
	bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化

	return 0;
}
```

### 52 using

#### using 声明

一条 `using 声明` 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：

```
using namespace_name::name;
```

#### 构造函数的 using 声明

在 C++11 中，派生类能够重用其直接基类定义的构造函数。

```C++
class Derived : Base {
public:
    using Base::Base;
    /* ... */
};
```

如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：

```
Derived(parms) : Base(args) { }
```

#### using 指示

`using 指示` 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：

```
using namespace_name name;
```

#### 尽量少使用 `using 指示` 污染命名空间

> 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它**只导入了指定的名称**。如果该名称与局部名称发生冲突，编译器将**发出指示**。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则**局部名称将覆盖名称空间版本**，而编译器**并不会发出警告**。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。

using 使用

尽量少使用 `using 指示`

```
using namespace std;
```

应该多使用 `using 声明`

```
int x;
std::cin >> x ;
std::cout << x << std::endl;
```

或者

```
using std::cin;
using std::cout;
using std::endl;
int x;
cin >> x;
cout << x << endl;
```

### 53 :: 范围解析运算符

#### 分类

1. 全局作用域符（`::name`）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
2. 类作用域符（`class::name`）：用于表示指定类型的作用域范围是具体某个类的
3. 命名空间作用域符（`namespace::name`）:用于表示指定类型的作用域范围是具体某个命名空间的

:: 使用

```C++
int count = 11;         // 全局（::）的 count

class A {
public:
	static int count;   // 类 A 的 count（A::count）
};
int A::count = 21;

void fun()
{
	int count = 31;     // 初始化局部的 count 为 31
	count = 32;         // 设置局部的 count 的值为 32
}

int main() {
	::count = 12;       // 测试 1：设置全局的 count 的值为 12

	A::count = 22;      // 测试 2：设置类 A 的 count 为 22

	fun();		        // 测试 3

	return 0;
}
```

### 54 decltype

decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：

```
decltype ( expression )
```

decltype 使用

```C++
// 尾置返回允许我们在参数列表之后声明返回类型
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
    // 处理序列
    return *beg;    // 返回序列中一个元素的引用
}
// 为了使用模板参数成员，必须用 typename
template <typename It>
auto fcn2(It beg, It end) -> typename remove_reference<decltype(*beg)>::type
{
    // 处理序列
    return *beg;    // 返回序列中一个元素的拷贝
}
```

### 55 引用

#### 左值引用

常规引用，一般表示对象的身份。

#### 右值引用

右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：

- 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
- 能够更简洁明确地定义泛型函数。

#### 引用折叠

- `X& &`、`X& &&`、`X&& &` 可折叠成 `X&`
- `X&& &&` 可折叠成 `X&&`

### 56 宏

- 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。

### 57. 成员初始化列表

好处

- 更高效：少了一次调用默认构造函数的过程。
- 有些场合必须要用初始化列表：
  1. 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
  2. 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
  3. 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化

```C++
class Weapon
{
private:
    string name;
    const string type;
    const string model;
public:
    Weapon(string& name, string& type, string& model) :name(name), type(type), model(model)
    {
        name = "Cloud";
    }
    string getProfile()
    {
        return "name: " + name + "\ntype: " + type + "\nmodel: " + model;
    }
};
```

### 58. initializer_list 列表初始化

用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 `std::initializer_list` 参数.

initializer_list 使用

```C++
#include <iostream>
#include <vector>
#include <initializer_list>
 
template <class T>
struct S {
    std::vector<T> v;
    S(std::initializer_list<T> l) : v(l) {
         std::cout << "constructed with a " << l.size() << "-element list\n";
    }
    void append(std::initializer_list<T> l) {
        v.insert(v.end(), l.begin(), l.end());
    }
    std::pair<const T*, std::size_t> c_arr() const {
        return {&v[0], v.size()};  // 在 return 语句中复制列表初始化
                                   // 这不使用 std::initializer_list
    }
};
 
template <typename T>
void templated_fn(T) {}
 
int main()
{
    S<int> s = {1, 2, 3, 4, 5}; // 复制初始化
    s.append({6, 7, 8});      // 函数调用中的列表初始化
 
    std::cout << "The vector size is now " << s.c_arr().second << " ints:\n";
 
    for (auto n : s.v)
        std::cout << n << ' ';
    std::cout << '\n';
 
    std::cout << "Range-for over brace-init-list: \n";
 
    for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作
        std::cout << x << ' ';
    std::cout << '\n';
 
    auto al = {10, 11, 12};   // auto 的特殊规则
 
    std::cout << "The list bound to auto has size() = " << al.size() << '\n';
 
//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，
                             // 它无类型，故 T 无法推导
    templated_fn<std::initializer_list<int>>({1, 2, 3}); // OK
    templated_fn<std::vector<int>>({1, 2, 3});           // 也 OK
}
```

### 59. **栈内存与文字常量区**

```text
        char str1[] = "abc";
　　char str2[] = "abc";
　　const char str3[] = "abc";
　　const char str4[] = "abc";
　　const char *str5 = "abc";
　　const char *str6 = "abc";
　　char *str7 = "abc";
　　char *str8 = "abc";
　　cout << ( str1 == str2 ) << endl;//0  分别指向各自的栈内存
　　cout << ( str3 == str4 ) << endl;//0  分别指向各自的栈内存
　　cout << ( str5 == str6 ) << endl;//1指向文字常量区地址相同
　　cout << ( str7 == str8 ) << endl;//1指向文字常量区地址相同
```

结果是：0 0 1 1

解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。

### 60. 智能指针

#### C++ 标准库（STL）中

头文件：`#include <memory>`

#### C++ 98

```
std::auto_ptr<std::string> ps (new std::string(str))；
```

#### C++ 11

1. shared_ptr
2. unique_ptr
3. weak_ptr
4. auto_ptr（被 C++11 弃用）

- Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。
- Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。

##### shared_ptr

多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。

- 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁

##### weak_ptr

weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。

- 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题

##### unique_ptr

unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。

- unique_ptr 用于取代 auto_ptr

##### auto_ptr

被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 `std::move` 语义，以及其他瑕疵。

##### auto_ptr 与 unique_ptr 比较

- auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了`move` 语义；
- auto_ptr 对象不能管理数组（析构调用 `delete`），unique_ptr 可以管理数组（析构调用 `delete[]` ）；

### 61. 内存屏障
https://zhuanlan.zhihu.com/p/55178896