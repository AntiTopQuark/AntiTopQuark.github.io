---
layout: post_draft
cid: 109
title: 杂项
date: 2021/04/13 17:49:00
author: AntiTopQuark
---


<!-- index-menu -->
#Java
#### HashMap 和 Hashtable 有什么区别？ 
- 存储：HashMap允许key 和 value 为 null，而 Hashtable 不允许。 
- 线程安全：Hashtable 是线程安全的，而 HashMap 是非线程安全的。 
推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。
#### HashMap为什么线程不安全
1. HashMap 1.7头插法 HashMap1.8尾插法

#### 并行和并发有什么区别？
并行：多个处理器或多核处理器同时处理多个任务。
并发：多个任务在同一个 CPU 核上，按细分的时间片轮流(交替)执行，从逻辑上来看那些任务是同时执行。

#计算机网络
#### tcp 为什么要三次握手，两次不行吗？为什么？
如果采用两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就白白浪费了一定的资源。若采用三次握手，服务器端没有收到来自客户端的再此确认，则就会知道客户端并没有要求建立请求，就不会浪费服务器的资源。

#### tcp 粘包可能发生在发送端或者接收端，分别来看两端各种产生粘包的原因：
发送端粘包：发送端需要等缓冲区满才发送出去，造成粘包；
接收方粘包：接收方不及时接收缓冲区的包，造成多个包接收。

Zookeeper
#### zookeeper 是什么？
zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。

#### zookeeper 都有哪些功能？
集群管理：监控节点存活状态、运行请求等。
主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。
分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。
命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。

#### zookeeper 有几种部署模式？
zookeeper 有三种部署模式：
单机部署：一台集群上运行；
集群部署：多台集群运行；
伪集群部署：一台集群启动多个 zookeeper 实例运行。
#### zookeeper 怎么保证主从节点的状态同步？
zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。

#### 集群中为什么要有主节点？
在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。



#### 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？
可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。

#### 说一下 zookeeper 的通知机制？
客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。


# Scala
#### 什么是闭包？（******************）
闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。
```scala
var factor = 3  
val multiplier = (i:Int) => i * factor 
```
闭包的实质就是代码与用到的非局部变量的混合，即：
闭包 = 代码 + 用到的非局部变量

####class 和 object 关系：

1.单例对象不能带参数，类可以
2.对象可以和类名一样时，object被称为伴生对象，class被称为伴生类；
3.类和伴生对象可以相互访问其私有属性，但是它们必须在一个源文件当中；
4.类只会被编译，不会被执行。要执行，必须在Object中。
#### case class 与 class 区别：
1.初始化的时候可以不用new，也可以加上，但是普通类必须加new;
2.默认实现了equals、hashCode方法；
3.默认是可以序列化的，实现了Serializable；
4.自动从scala.Product中继承一些函数;
5.case class 构造函数参数是public的，我们可以直接访问；
6.case class默认情况下不能修改属性值；
7.case class最重要的功能，支持模式匹配，这也是定义case class的重要原因。

#操作系统
#### 进程线程的区别
1、进程是资源分配的最小单位，线程是程序执行的最小单位（资源调度的最小单位）
2、进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。
而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
3、线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
4、但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。


 
